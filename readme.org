#+TITLE: codygman's HCI
* What is this?
** This is my personal human computer interaction interface based on:
*** Emacs
*** [[https://orgmode.org/][Org-mode]] for literate config management, life planning, and so much more
*** Reproducible system level builds with [[https://nixos.org/nix/][Nix]]
*** Reproducible Emacs package builds with [[https://github.com/raxod502/straight.el][straight.el]]
*** [[https://github.com/hlissner/doom-emacs/][doom-emacs]] for modal editing
* Core values:
** ALWAYS be reproducible
   :PROPERTIES:
   :ID:       2bed02e1-aa52-4332-a4eb-b213ce1b3468
   :END:

   The way you interact with your computer must be rock-solid, have the ability to rollback to any meaningful point in history in case of regressions, and be solid down to the theory behind it.

   Nix provides this guarantee, but sadly the syntax isn't the most pleasing and the documentation can be non-existent.

   If you're willing to "use the source" though, you can attain these guarantees that are necessary in constructing a reliable HCI system that doesn't make you want to pull your hair out.
** Performance over features
   I've wavered on this one over the years, but hindering the perceptive feeling of something as important as your interface with your computer causes lots of issues and personally led to me not even using it.

   I learned some good lessons about minimalism and the necessity of "just my editor config" that was truly a partial HCI being a full-blown software project with feature-branches, user testing, performance regression testing, etc.
** Easy to extend
   One thing that makes emacs great is the ability to just change things on the fly.

   This also hurts reproducibility and predictable performance if you aren't careful though.
** Fuzzy-search and incremental narrowing everywhere
   I'm currently using ivy since doom defaults to it, but in the past I've used and made significant add-ons for helm. I may well start using helm again unless ivy is even easier to customize somehow.

   I would like to make *all* navigation for anything I do on a computer to be done from a common narrowing framework with state of the art fuzzy finding (which I don't recall getting easily with emacs, but see 'flx' for a good start).

*** Navigation for anything I do including but not limited to
**** TODO fuzzy omni-search for everything listed below
     I'd expect this to be slow without lots of work and probably a backing sqlite database, but something similar to [[https://beepb00p.xyz/pkm-search.html][Building personal search infrastructure for your knowledge and code]]. Perhaps that's even exactly what I want. See the [[https://news.ycombinator.com/item?id=22160572][HackerNews discussion]] as well.

     Having things like apple's finder which shows filenames and tons of other stuff would also be nice
**** TODO Github [0/2]
***** TODO general github search/navigation
      =M-x helm-github= would bring up sections

      - notifications
      - repos

      Selecting a notification would open that link in the browser (in the future maybe relevant content and contextual actions via =helm-github-action= or similar. Think things like an action for a PR like =setup branch locally= that opens new perspective, clones the repo, checks out the given branch, open dired, and if supported start up repl that splits below the dired buffer
***** TODO searching github for code snippets
      Frequently I look for examples of how to do things in home-manager in github. One situation is where I don't know how to setup xmonad and configure it with home-manager I can just search github for others configurations like:

      #+begin_example
      filename:home.nix xmonad
      #+end_example

      It's okay to use Github's interface for this, but I'd prefer to stay in emacs and even open the linked results in a temporary buffer. Another nicety would be optional actions to clone the repo somewhere like ~/code or even somewhere contextually relevant like ~/code/nix-configs. All along the way using incremental narrowing.
**** TODO searching email
     I'd like something like =helm-email= which searches all of my emails with fuzzy search. If I transition to something like notmuch again or mu4e then this is a lot more easily possible on my desktop machines, not so sure about mobile however.
**** TODO browsing issue and bug tracking software
***** TODO clubhouse
****** listing "dashboard view" in sections with fuzzy searching
****** contextual opening based on templates
       This one requires much more
***** SOMEDAY (maybe) jira and others
** Be nice to use
   If it's not subjectively nice for me to use, then I probably won't use it as much as I should.
* TODO Reproducible Quickstart (warning: not idempotent, don't run more than once)
** Assumes =codygman/hci= repo cloned and setup
*** start emacs in a nix shell
    #+BEGIN_SRC sh
    nix-shell --pure -I nixpkgs=https://github.com/NixOS/nixpkgs-channels/archive/d5291756487d70bc336e33512a9baf9fa1788faf.tar.gz -p emacs git
    #+END_SRC
*** =C-x C-f= your way to ~/hci/readme.org
*** come back to this specific spot from emacs, then tangle or evaluate the source code blocks as appropriate
*** clone =codygman/hci=
    #+begin_src sh :dir ~
    git clone git@github.com:codygman/codygman/hci.git
    #+end_src
*** setup
    :PROPERTIES:
    :ID:       51d79bf3-53bd-4fc4-83d0-8616c0718d65
    :END:
    #+begin_src sh :tangle /tmp/setup.sh
      # mv current emacs somewhere else (or remove if you don't need it)
      mv ~/.emacs.d ~/.bak.emacs.d
      git clone -b develop git://github.com/hlissner/doom-emacs ~/.emacs.d
      ln -rs ~/codygman/hci/doom.d ~/doom.d
      # assuming "personal" env
      cd ~/.emacs.d
      cd MYENV="personal" ./switch.hs
      ~/.emacs.d/bin/doom install
    #+end_src

    #+RESULTS:

*** tangle the above like
**** navigate into the block
**** =SPC u C-c C-v t=
**** =SPC o t= to popup a terminal
**** from within the terminal
     #+BEGIN_SRC sh
       cd /tmp/
       sh setup.sh
     #+END_SRC
*** common issues
**** "'X' and 'Y' have the same priority; use nix-env --set-flag..."
***** python for instance
****** error
       #+begin_example
       error: packages '/nix/store/ghcaj8k1psh6z93pdzajcy9r1337is9j-home-manager-path/lib/python3.7/site-packages/nox/__pycache__/search.cpython-37.pyc' and '/nix/store/7qnzacibiapc2wl49lckh0y7sl6q5hpy-nox-0.0.6/lib/python3.7/site-packages/nox/__pycache__/search.cpython-37.pyc' have the same priority 5; use 'nix-env --set-flag priority NUMBER INSTALLED_PKGNAME' to change the priority of one of the conflicting packages (0 being the highest priority)
       #+end_example
****** =NOTE= the library name immediately after =/store/= is =nox= so it is what is causing the clash
****** resolution
       #+begin_src sh
	 nix-env --uninstall nox
       #+end_src

       #+RESULTS:
***** why does this happen?
****** when you start using [[https://github.com/rycee/home-manager.git][home-manager]] you'll likely already have installed things you want home-manager to install
****** That means since nix at the system level installed them and now home-manager is installing them, they clash because there is no answer to "which is higher priority"
****** the message is technically correct here, but a little misleading for the home-manager centric case where we'd the ideal message would be:
       "Please uninstall the system level version of 'nox' if you want home-manager to manage it, otherwise remove it from your home-manager configuration"
** TODO make running this a no-op if already installed
* Getting Help
  
  With a many systems on top of systems, complexity abound, and the stakes sometimes high for not being able to figure something out for a given piece of that system seeking out help in the best places and getting it quickly is paramount.

  The following sections are ordered by how often I need to seek out help for that section. This is subject to change, so if doom becomes the thing I seek help out for the least then it will get moved down.

  Within each section, help resources should be ordered mostly according to typical time required to get an answer.

** Doom
*** [[https://discord.gg/qvGgnVx][doom-emacs Discord]]

    Very active, very helpful. I hear you can use [[https://www.reddit.com/r/emacs/comments/7poez4/emacs_and_discord/dsiyr8n/][Bitlbee, and Bitlbee-Discord to connect with your irc client]]

** Nix
*** https://discourse.nixos.org/
*** #nix on freenode
**** TODO make this a link to your irc client!
*** [[https://nixos.org/nixpkgs/manual/][Nixpkgs Users and Contributors Guide]]
*** https://nixos.wiki/

** Emacs
*** [[https://emacs.stackexchange.com/][Emacs stack exchange]]

** org-mode
*** [[https://www.reddit.com/r/orgmode/][r/orgmode/]]
*** [[https://emacs.stackexchange.com/][Emacs stack exchange]] using the org mode tag
    You should use [[https://github.com/vermiculus/sx.el][stack exchange for emacs]]!

** straight.el
*** https://github.com/raxod502/straight.el/issues
* Configuration
** Prevent use-package from installing anything
*** Set ensure-function to nil
    #+begin_src emacs-lisp
      (setq use-package-ensure-function 'ignore)
    #+end_src
*** Set package-archives to nil so there's nothing to install from

    Package should already be there, to add a new one add it to home.nix

    #+begin_src emacs-lisp
      (setq package-archives nil)
    #+end_src
** Core Emacs Configuration
*** Font stuff
    #+begin_src emacs-lisp
      ;; Set default font
      (set-face-attribute 'default nil
			  :family "Source Code Pro"
			  :height 160
			  :weight 'normal
			  :width 'normal)
    #+end_src

    #+begin_src emacs-lisp
      (add-hook 'text-mode-hook
		(lambda ()
		  (variable-pitch-mode 1)))
    #+end_src
*** Set a custom custom-file
    #+begin_src emacs-lisp
      (setq custom-file "~/.emacs-custom.el")
    #+end_src
*** Don't generate annoying backup files in current directory
    #+begin_src emacs-lisp
      (setq backup-directory-alist `(("." . "~/.saves")))
      (setq delete-old-versions t
	    kept-new-versions 6
	    kept-old-versions 2
	    version-control t)
      (setq backup-by-copying-when-linked t)
    #+end_src
*** Hide annoying things
    #+begin_src emacs-lisp
      (tool-bar-mode -1)
      (toggle-scroll-bar -1)
      (menu-bar-mode -1)
    #+end_src
*** Misc
    #+begin_src emacs-lisp
      ;; always follow symlinks and DONT PROMPT ME
      (setq vc-follow-symlinks t)

      (defalias 'yes-or-no-p 'y-or-n-p)
    #+end_src
** Package configuration
*** use-package
    #+begin_src emacs-lisp
      (require 'use-package)
    #+end_src
*** which-key
    #+begin_src emacs-lisp
      (use-package which-key
	:init
	(setq which-key-separator " ")
	(setq which-key-prefix-prefix "+")
	:config
	(which-key-mode))
    #+end_src
*** general (Best leave this loading near the top)
    #+begin_src emacs-lisp
      (use-package general
	:after which-key
	:init
	(setq evil-want-keybinding nil
	      evil-want-C-d-scroll t
	      evil-want-C-u-scroll t
	      evil-want-integration t
	      )
	:config
	(general-auto-unbind-keys) ;; NOTE not sure this works?
	(general-evil-setup t)
	(general-imap "j"
	  (general-key-dispatch 'self-insert-command
	    :timeout 0.25
	    ;; TODO make this work so jf writes the file when I enter normal mode
	    ;; "j" '(my-write-then-normal-state)
	    "f" 'evil-normal-state))
	(general-create-definer my-leader-def
	  :prefix "C")
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  "u"   '(universal-argument :which-key "Universal Argument")
	  "tf" '(toggle-frame-fullscreen :which-key "Toggle Fullscreen")
	  "wd" '(delete-window :which-key "Delete Window")
	  "qq" '(save-buffers-kill-terminal :which-key "Quit Emacs")

	  "hf" '(describe-function :which-key "Describe Function")
	  "hk" '(describe-key :which-key "Describe Key")
	  "ha" '(apropos-command :which-key "Apropos Command")

	  ;; window
	  "wm"  '(toggle-maximize-buffer :which-key "maximize buffer")
	  "wh"  '(evil-window-left :which-key "move left")
	  "wj"  '(evil-window-down :which-key "move down a window")
	  "wk"  '(evil-window-up :which-key "move up a window")
	  "wl"  '(evil-window-right :which-key "move right a window")
	  "wv"  '(split-window-right :which-key "split right a window")
	  "ws"  '(split-window-below :which-key "split bottom")
	  )
	)
    #+end_src
*** evil and evil collection
    #+begin_src emacs-lisp
      (use-package evil
        :after general
	:config
	(evil-mode 1)
	:general
	;; NOTE For some reason general binding is broken in the evil block
	)

      (use-package evil-collection
	:after evil
	:config
	(evil-collection-init))
    #+end_src
*** evil-magit
    #+begin_src emacs-lisp
      (use-package evil-magit :after evil :config (evil-magit-init))
    #+end_src
*** dired
    #+begin_src emacs-lisp
      (use-package dired
	:general
      (my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "o-" 'dired
	  ))
    #+end_src
*** save-hist-mode           :built-in:
    #+begin_src emacs-lisp
      (use-package savehist
	:init
	(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
	(setq savehist-file "~/.emacs.d/savehist")
	:config
	(savehist-mode 1)
	)

    #+end_src

*** magit
    #+begin_src emacs-lisp
      (use-package magit
	:init
	;; TODO write test for this
	(add-hook 'with-editor-mode-hook 'evil-insert-state)

	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "gg" 'magit-status
	  )
	)
    #+end_src

*** projectile
    #+begin_src emacs-lisp
	    (use-package projectile
	      :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
		"pa" '(projectile-add-known-project :wk "Projectile add known project")
		)
	      :config
	      (projectile-mode +1))
    #+end_src
*** haskell-mode
    #+begin_src emacs-lisp
      (use-package haskell-mode
	:mode ("\\.hs\\'" . haskell-mode)
	:init
	(message "personal haskell-mode loading")
	(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
	(add-hook 'haskell-mode-hook 'haskell-indentation-mode))
    #+end_src
*** flycheck
    #+begin_src emacs-lisp
	    (use-package flycheck
	      :init
	      (setq flycheck-executable-find
		    (lambda (cmd)
		      ;; (message (format "updating default directory with direnv: %s") default-directory)
		      (direnv-update-environment default-directory)
		      ;;(sit-for 1)
		      (executable-find cmd)))
	      ;; (setq-default flycheck-disabled-checkers '(haskell-stack-ghc))
	      (global-flycheck-mode))

      (use-package flycheck-haskell
	:config
	;; :init
	;; (advice-add 'direnv-update-directory-environment :before #'flycheck-haskell-setup)
	:hook (haskell-mode . flycheck-haskell-setup))
    #+end_src
*** direnv mode
    #+begin_src emacs-lisp
    (defun myadvice (&optional directory force-summary)
        ;; (flycheck-haskell-configure)
     )
      (use-package direnv
        :after flycheck-haskell
	:init 
	:config
        
	(direnv-mode))
    #+end_src
*** color theme
    #+begin_src emacs-lisp
      ;; TODO figure out why use-package doesn't work here
      (load-theme 'doom-one t)
    #+end_src
*** compilation mode
    #+begin_src emacs-lisp
      (use-package compile
	:init
	(setq compilation-scroll-output t) ;; TODO test

	(require 'ansi-color)
	(defun endless/colorize-compilation ()
	  "Colorize from `compilation-filter-start' to `point'."
	  (let ((inhibit-read-only t))
	    (ansi-color-apply-on-region
	     compilation-filter-start (point))))
	(add-hook 'compilation-filter-hook
		  #'endless/colorize-compilation)

	;; :hook (compilation-filter-hook  endless/colorize-compilation)
	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "cc" '(recompile :which-key "M-x recompile")
	  "cC" '(compile :which-key "M-x compile")
	  )
	)

    #+end_src
*** winner mode
    #+begin_src emacs-lisp
      (use-package winner
	:config
	(winner-mode 1)
	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "wu" '(winner-undo :which-key "Winner Undo")
	  "wr" '(winner-redo :which-key "Winner Redo")
	  )
	)
    #+end_src
*** Helm
#+begin_src emacs-lisp
  (use-package helm-swoop
    :init
    (setq helm-swoop-split-with-multiple-windows t
	  helm-swoop-split-direction 'split-window-vertically
	  helm-swoop-speed-or-color t
	  helm-swoop-split-window-function 'helm-default-display-buffer
	  helm-swoop-pre-input-function (lambda () ""))
    :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	:prefix "SPC"
	"ss" '(helm-swoop :which-key "helm swoop")
	)
    )

    (use-package helm
      :init
      (setq helm-M-x-fuzzy-match t
	    helm-mode-fuzzy-match t
	    helm-buffers-fuzzy-matching t
	    helm-recentf-fuzzy-match t
	    helm-locate-fuzzy-match t
	    helm-semantic-fuzzy-match t
	    helm-imenu-fuzzy-match t
	    helm-completion-in-region-fuzzy-match t
	    helm-candidate-number-list 80
	    ;; helm-split-window-in-side-p t
	    helm-move-to-line-cycle-in-source t
	    helm-echo-input-in-header-line t
	    helm-autoresize-max-height 0
	    helm-autoresize-min-height 20
	    helm-always-two-windows t
	    )
      :general
      ;; TODO change rest of general def's to use this instead of nmap?
      (my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	"ff" 'helm-find-files
	":" '(helm-M-x :which-key "M-x")
	"bb" '(switch-to-buffer :which-key "Switch to buffer")
	"bd" '(kill-buffer :which-key "Kill Buffer")
	)
      :config
      ;; (use-package helm-flx)
      ;; (use-package helm-fuzzier)
      (use-package helm-rg)
      (helm-mode 1)
      ;; (helm-flx-mode 1)
      ;; (helm-fuzzier-mode 1)
      :bind (:map helm-map
		  ("<tab>" . helm-execute-persistent-action)
		  ("C-h" . helm-find-files-up-one-level)
		  ("<backtab>" . helm-find-files-up-one-level)
		  ("C-z" . helm-select-action)
		  )
      )

    (use-package helm-projectile
      :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	"pp"  '(helm-projectile-switch-project :which-key "switch project")
	"pb"  '(helm-projectile-switch-to-buffer :which-key "switch buffer")
	"pf" 'helm-projectile-find-file
	"SPC" 'helm-projectile-find-file
	)
      )
#+end_src
*** nix-mode
    #+begin_src emacs-lisp
      (use-package nix
        :defer nil
        :mode ("\\.nix\\'" . nix-mode))
    #+end_src
*** lsp
    #+begin_src emacs-lisp
      (use-package lsp-mode
	:hook ((haskell-mode . lsp-deferred)
	       (lsp-mode . lsp-enable-which-key-integration))
	:commands (lsp lsp-deferred)
	:config 
	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'haskell-mode-map ;; TODO isn't there an lsp mode map?
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "ca" '(lsp-execute-code-action :wk "lsp execute code action")
	  )
	)

      (use-package lsp-haskell
	:init
	(setq lsp-haskell-process-path-hie "ghcide")
	(setq lsp-haskell-process-args-hie nil)
	)
      (general-def
	:prefix ", c"
	:states '(normal visual)
	:keymaps 'haskell-mode-map
	"L" 'flycheck-list-errors
	"b" 'flycheck-buffer
	"c" 'flycheck-clear
	"l" 'lsp-ui-flycheck-list
	"n" 'flycheck-next-error
	"p" 'flycheck-previous-error)

      (use-package lsp-ui
	:commands lsp-ui-mode
	:config
	;; (setq lsp-ui-flycheck-live-reporting nil)
	;; (setq lsp-ui-sideline-enable nil)
	;; (setq lsp-ui-doc-enable nil)
	;; (setq lsp-ui-sideline-show-diagnostics nil)
	)

      (use-package company-lsp
	:config
	(setq company-minimum-prefix-length 1
	      company-idle-delay 0.01)
      (push 'company-lsp company-backends))

      ;; TODO move company to own block
      (use-package company
	:init
	(add-hook 'haskell-mode-hook 'company-mode)
	:bind (:map haskell-mode-map
		    ("TAB" . company-indent-or-complete-common)))


    #+end_src
*** helper functions
**** toggle maximize buffer
     #+begin_src emacs-lisp
       (defun toggle-maximize-buffer () "Maximize buffer"
	      (interactive)
	      (if (= 1 (length (window-list)))
		  (jump-to-register '_)
		(progn
		  (window-configuration-to-register '_)
		  (delete-other-windows))))
     #+end_src
* NOTE 
** This [[https://github.com/codygman/my-emacs-everywhere/blob/4898bc236fcff390d587e69831f3c17019e027f0/emacs-config.org][minimal literate config]] I wrote is probably useful
*** use graphic p stuff 
** Random Things TODO
*** BIG NOTE: crib from [[file:~/code/minimal-emacs-literate-workflow/init.el::;; prevent gc during startup][minimal-emacs-literate-workflow config]]
    also https://git.sr.ht/~codygman/emacs-config/tree/master
*** DONE window management
    SPC j (up) SPC l (left) etc

I've *really* missed this one.... =C-x o= gets old fast
*** DONE simple flycheck
**** DONE elisp 
**** DONE shellcheck
**** DONE haskell
*** DONE emacs y-or-n-p
*** DONE spc b d kill buffer
*** DONE compilation mode bindings (SPC c c/SPC c C)
*** DONE =SPC w {u,r}= for winner undo/redo
*** TODO =SPC '= search project (or skip this one and use SPC s p all time?)
**** problem
    At work I've been trying to run =helm-projectile-rg= and having some weird issue I havnt had time to debug
**** exploring why it's broke/solutions
***** turn on debug on error
      #+begin_src emacs-lisp
      (setq debug-on-error t)
      #+end_src

      #+RESULTS:
      : t
***** call =SPC : helm-projectile-rg RET=
***** When I get to typing the second character and I'm guessing it calls rg I get
      #+begin_example
	Debugger entered--Lisp error: (wrong-type-argument string nil cur-file)
	  signal(wrong-type-argument (string nil cur-file))
	  (or (stringp cur-file) (signal 'wrong-type-argument (list 'string cur-file 'cur-file)))
	  (progn (or (stringp cur-file) (signal 'wrong-type-argument (list 'string cur-file 'cur-file))) nil)
	  (let ((whole-line sym) (content sym) (line-num-str sym) (propertized-line x128) (match-regions x133)) (progn (or (stringp cur-file) (signal 'wrong-type-argument (list 'string cur-file 'cur-file))) nil) (let ((_content content) (_whole-line whole-line)) (let* ((prefixed-line (helm-rg--join-output-line :cur-file (and helm-rg-include-file-on-every-match-line cur-file) :line-num-str line-num-str :propertized-line propertized-line)) (line-num (string-to-number line-num-str)) (jump-to (list :file cur-file :line-num line-num :match-results match-regions)) (output-line (propertize prefixed-line helm-rg--jump-location-text-property jump-to))) (list :file-path cur-file :line-content output-line))))
	  (let* ((x133 (car x132))) (let ((whole-line sym) (content sym) (line-num-str sym) (propertized-line x128) (match-regions x133)) (progn (or (stringp cur-file) (signal 'wrong-type-argument (list 'string cur-file 'cur-file))) nil) (let ((_content content) (_whole-line whole-line)) (let* ((prefixed-line (helm-rg--join-output-line :cur-file (and helm-rg-include-file-on-every-match-line cur-file) :line-num-str line-num-str :propertized-line propertized-line)) (line-num (string-to-number line-num-str)) (jump-to (list :file cur-file :line-num line-num :match-results match-regions)) (output-line (propertize prefixed-line helm-rg--jump-location-text-property jump-to))) (list :file-path cur-file :line-content output-line)))))
	  (cond ((consp x132) (let* ((x133 (car x132))) (let ((whole-line sym) (content sym) (line-num-str sym) (propertized-line x128) (match-regions x133)) (progn (or (stringp cur-file) (signal 'wrong-type-argument (list ... cur-file ...))) nil) (let ((_content content) (_whole-line whole-line)) (let* ((prefixed-line ...) (line-num ...) (jump-to ...) (output-line ...)) (list :file-path cur-file :line-content output-line)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((x132 (cdr x130))) (cond ((consp x132) (let* ((x133 (car x132))) (let ((whole-line sym) (content sym) (line-num-str sym) (propertized-line x128) (match-regions x133)) (progn (or (stringp cur-file) (signal ... ...)) nil) (let ((_content content) (_whole-line whole-line)) (let* (... ... ... ...) (list :file-path cur-file :line-content output-line)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  (cond ((eq x131 :match-regions) (let* ((x132 (cdr x130))) (cond ((consp x132) (let* ((x133 ...)) (let (... ... ... ... ...) (progn ... nil) (let ... ...)))) ((string-match (rx-to-string '...) line) (let* ((sym ...) (sym ...)) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((x131 (car x130))) (cond ((eq x131 :match-regions) (let* ((x132 (cdr x130))) (cond ((consp x132) (let* (...) (let ... ... ...))) ((string-match (rx-to-string ...) line) (let* (... ...) (funcall pcase-0 sym sym))) (t (let (...) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  (cond ((consp x130) (let* ((x131 (car x130))) (cond ((eq x131 :match-regions) (let* ((x132 ...)) (cond (... ...) (... ...) (t ...)))) ((string-match (rx-to-string '...) line) (let* ((sym ...) (sym ...)) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((x128 (car x127)) (x130 (helm-rg--flipped-plist-member :match-regions sym))) (cond ((consp x130) (let* ((x131 (car x130))) (cond ((eq x131 :match-regions) (let* (...) (cond ... ... ...))) ((string-match (rx-to-string ...) line) (let* (... ...) (funcall pcase-0 sym sym))) (t (let (...) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  (cond ((consp x127) (let* ((x128 (car x127)) (x130 (helm-rg--flipped-plist-member :match-regions sym))) (cond ((consp x130) (let* ((x131 ...)) (cond (... ...) (... ...) (t ...)))) ((string-match (rx-to-string '...) line) (let* ((sym ...) (sym ...)) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((x127 (cdr x125))) (cond ((consp x127) (let* ((x128 (car x127)) (x130 (helm-rg--flipped-plist-member :match-regions sym))) (cond ((consp x130) (let* (...) (cond ... ... ...))) ((string-match (rx-to-string ...) line) (let* (... ...) (funcall pcase-0 sym sym))) (t (let (...) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  (cond ((eq x126 :propertized-line) (let* ((x127 (cdr x125))) (cond ((consp x127) (let* ((x128 ...) (x130 ...)) (cond (... ...) (... ...) (t ...)))) ((string-match (rx-to-string '...) line) (let* ((sym ...) (sym ...)) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((x126 (car x125))) (cond ((eq x126 :propertized-line) (let* ((x127 (cdr x125))) (cond ((consp x127) (let* (... ...) (cond ... ... ...))) ((string-match (rx-to-string ...) line) (let* (... ...) (funcall pcase-0 sym sym))) (t (let (...) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  (cond ((consp x125) (let* ((x126 (car x125))) (cond ((eq x126 :propertized-line) (let* ((x127 ...)) (cond (... ...) (... ...) (t ...)))) ((string-match (rx-to-string '...) line) (let* ((sym ...) (sym ...)) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((x125 (helm-rg--flipped-plist-member :propertized-line sym))) (cond ((consp x125) (let* ((x126 (car x125))) (cond ((eq x126 :propertized-line) (let* (...) (cond ... ... ...))) ((string-match (rx-to-string ...) line) (let* (... ...) (funcall pcase-0 sym sym))) (t (let (...) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  (cond ((let* ((G61 x124)) (not (-difference G61 '(:propertized-line :match-regions)))) (let* ((x125 (helm-rg--flipped-plist-member :propertized-line sym))) (cond ((consp x125) (let* ((x126 ...)) (cond (... ...) (... ...) (t ...)))) ((string-match (rx-to-string '...) line) (let* ((sym ...) (sym ...)) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((sym (let* ((G60 line)) (match-string 1 G60))) (sym (let* ((G60 line)) (match-string 2 G60))) (sym (let* ((G60 line)) (match-string 3 G60))) (sym (let* ((content sym)) (helm-rg--parse-propertize-match-regions-from-match-line content))) (x124 (helm-rg--plist-keys sym))) (cond ((let* ((G61 x124)) (not (-difference G61 '(:propertized-line :match-regions)))) (let* ((x125 (helm-rg--flipped-plist-member :propertized-line sym))) (cond ((consp x125) (let* (...) (cond ... ... ...))) ((string-match (rx-to-string ...) line) (let* (... ...) (funcall pcase-0 sym sym))) (t (let (...) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  (cond ((string-match (rx-to-string '(: bos eos)) line) (list :file-path nil)) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) ":" (group-n 3 ...) eos))) line) (let* ((sym (let* ((G60 line)) (match-string 1 G60))) (sym (let* ((G60 line)) (match-string 2 G60))) (sym (let* ((G60 line)) (match-string 3 G60))) (sym (let* ((content sym)) (helm-rg--parse-propertize-match-regions-from-match-line content))) (x124 (helm-rg--plist-keys sym))) (cond ((let* ((G61 x124)) (not (-difference G61 ...))) (let* ((x125 ...)) (cond (... ...) (... ...) (t ...)))) ((string-match (rx-to-string '...) line) (let* ((sym ...) (sym ...)) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos (group-n 2 ...) eos))) line) (let* ((sym (let* ((G62 line)) (match-string 1 G62))) (sym (let* ((G62 line)) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123))))
	  (let* ((pcase-0 #'(lambda (file-path whole-line) (let* ((whole-line-effaced ...) (file-path-effaced ...) (jump-to ...) (output-line ...)) (append (list :file-path file-path-effaced) (and helm-rg-prepend-file-name-line-at-top-of-matches ...)))))) (cond ((string-match (rx-to-string '(: bos eos)) line) (list :file-path nil)) ((string-match (rx-to-string '(group-n 1 (: bos ... ":" ... eos))) line) (let* ((sym (let* (...) (match-string 1 G60))) (sym (let* (...) (match-string 2 G60))) (sym (let* (...) (match-string 3 G60))) (sym (let* (...) (helm-rg--parse-propertize-match-regions-from-match-line content))) (x124 (helm-rg--plist-keys sym))) (cond ((let* (...) (not ...)) (let* (...) (cond ... ... ...))) ((string-match (rx-to-string ...) line) (let* (... ...) (funcall pcase-0 sym sym))) (t (let (...) (error "No clause matching `%S'" x123)))))) ((string-match (rx-to-string '(group-n 1 (: bos ... eos))) line) (let* ((sym (let* (...) (match-string 1 G62))) (sym (let* (...) (match-string 2 G62)))) (funcall pcase-0 sym sym))) (t (let ((x123 line)) (error "No clause matching `%S'" x123)))))
	  helm-rg--process-transition(nil #("1:start waiting for ghci at Fri Jul 10 17:33:29 20..." 0 1 (font-lock-face (foreground-color . "#98be65")) 16 18 (font-lock-face ((foreground-color . "#ff6c6b") bold))))
	  (let ((parsed (helm-rg--process-transition cur-file colored-line))) (if parsed (let* ((--cl-rest-- parsed) (file-path (car (cdr (plist-member --cl-rest-- ...)))) (line-content (car (cdr (plist-member --cl-rest-- ...))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond (... ...) (... ...) (t ...)))) (set (make-local-variable 'helm-rg--process-output-parse-state) (list :cur-file file-path)) (or line-content ""))) (error "Line '%s' could not be parsed! state was: '%S'" colored-line helm-rg--process-output-parse-state)))
	  (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '(:cur-file :allow-other-keys)) (setq --cl-keys-- (cdr (cdr --cl-keys--)))) ((car (cdr (memq ... --cl-rest--))) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:cur-file)" (car --cl-keys--)))))) (let ((parsed (helm-rg--process-transition cur-file colored-line))) (if parsed (let* ((--cl-rest-- parsed) (file-path (car (cdr ...))) (line-content (car (cdr ...)))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ... ... ...))) (set (make-local-variable 'helm-rg--process-output-parse-state) (list :cur-file file-path)) (or line-content ""))) (error "Line '%s' could not be parsed! state was: '%S'" colored-line helm-rg--process-output-parse-state))))
	  (let* ((--cl-rest-- helm-rg--process-output-parse-state) (cur-file (car (cdr (plist-member --cl-rest-- ':cur-file))))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ((memq (car --cl-keys--) '...) (setq --cl-keys-- (cdr ...))) ((car (cdr ...)) (setq --cl-keys-- nil)) (t (error "Keyword argument %s not one of (:cur-file)" (car --cl-keys--)))))) (let ((parsed (helm-rg--process-transition cur-file colored-line))) (if parsed (let* ((--cl-rest-- parsed) (file-path (car ...)) (line-content (car ...))) (progn (let (...) (while --cl-keys-- ...)) (set (make-local-variable ...) (list :cur-file file-path)) (or line-content ""))) (error "Line '%s' could not be parsed! state was: '%S'" colored-line helm-rg--process-output-parse-state)))))
	  (let* ((colored-line (ansi-color-apply input-line)) (string-result (let* ((--cl-rest-- helm-rg--process-output-parse-state) (cur-file (car (cdr ...)))) (progn (let ((--cl-keys-- --cl-rest--)) (while --cl-keys-- (cond ... ... ...))) (let ((parsed ...)) (if parsed (let* ... ...) (error "Line '%s' could not be parsed! state was: '%S'" colored-line helm-rg--process-output-parse-state))))))) string-result)
	  helm-rg--parse-process-output(#("1:start waiting for ghci at Fri Jul 10 17:33:29 20..." 0 1 (font-lock-face (foreground-color . "#98be65")) 16 18 (font-lock-face ((foreground-color . "#ff6c6b") bold))))
	  helm-output-filter--process-source(#<process *helm-rg--rg*> "kgs/nix/mylib.nix\33[0m\n\33[0m\33[32m1..." ((name . #("argv: /home/cody/.nix-profile/bi..." 6 36 (face helm-rg-base-rg-cmd-face) 37 49 (face helm-rg-active-arg-face) 50 62 (face helm-rg-inactive-arg-face) 63 84 (face helm-rg-inactive-arg-face) 85 110 (face helm-rg-inactive-arg-face) 111 113 (face font-lock-string-face))) (header-name . helm-rg--header-name) (keymap keymap (left . helm-rg--file-backward) (right . helm-rg--file-forward) (27 keymap (99 . helm-rg--set-case-sensitivity) (100 . helm-rg--set-dir) (109 . helm-rg--set-extra-args) (103 . helm-rg--set-glob) (98 . helm-rg--bounce)) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." (32 . helm-toggle-visible-mark) (121 keymap ... ... ...) (47 . helm-quit-and-find-file) (71 . helm-end-of-buffer) (107 . helm-previous-line) (106 . helm-next-line) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (103 keymap ... ... ... ...) (93 keymap ...) (91 keymap ...) (tab . helm-select-action) (4 . helm-next-page) (21 . helm-previous-page) (15 . helm-next-source) (14 . helm-next-line) (16 . helm-previous-line) (22 . helm-next-page) (13 . helm-maybe-exit-minibuffer) (2 . helm-previous-page) (6 . helm-next-page) (27 keymap ... ... ... ... ... ...)) (insert-state keymap "Auxiliary keymap for Insert stat..." (15 . helm-next-source) (14 . helm-next-line) (16 . helm-previous-line) (22 . helm-next-page) (13 . helm-maybe-exit-minibuffer) (2 . helm-previous-page) (6 . helm-next-page) (27 keymap ... ... ... ... ... ...)) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil (interactive) (helm-select-nth-action 12)) (f12 lambda nil (interactive) (helm-select-nth-action 11)) (f11 lambda nil (interactive) (helm-select-nth-action 10)) (f10 lambda nil (interactive) (helm-select-nth-action 9)) (f9 lambda nil (interactive) (helm-select-nth-action 8)) (f8 lambda nil (interactive) (helm-select-nth-action 7)) (f7 lambda nil (interactive) (helm-select-nth-action 6)) (f6 lambda nil (interactive) (helm-select-nth-action 5)) (f5 lambda nil (interactive) (helm-select-nth-action 4)) (f4 lambda nil (interactive) (helm-select-nth-action 3)) (f3 lambda nil (interactive) (helm-select-nth-action 2)) (f2 lambda nil (interactive) (helm-select-nth-action 1)) (menu-bar keymap (help-menu keymap ...)) (help keymap (109 . helm-help)) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil (interactive) (helm-select-nth-action 0)) (8 . helm-find-files-up-one-level) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (67108897 . helm-toggle-suspend-update) ...) (action ("Visit" . helm-rg--async-action)) (persistent-action . helm-rg--async-persistent-action) (persistent-help . "Visit result buffer and highligh...") (help-message . "FIXME: useful help message!!!") (filtered-candidate-transformer . helm-grep-fc-transformer) (filter-one-by-one . helm-rg--parse-process-output) (display-to-real . helm-rg--display-to-real) (candidate-number-limit . 99999) (redisplay . identity) (nomark . t) (nohighlight . t) (history . helm-rg--input-history) (header-line . "C-j: Visit result buffer and hig...") (group . helm-rg) (candidates-process . helm-rg--make-process) (pcre . t) (item-count . 179) (incomplete-line . "\33[0m\33[32m36\33[0m") (insertion-marker . #<marker at 115 in *helm-rg*>)) 99999)
	  helm-output-filter-1((#<process *helm-rg--rg*> (name . #("argv: /home/cody/.nix-profile/bi..." 6 36 (face helm-rg-base-rg-cmd-face) 37 49 (face helm-rg-active-arg-face) 50 62 (face helm-rg-inactive-arg-face) 63 84 (face helm-rg-inactive-arg-face) 85 110 (face helm-rg-inactive-arg-face) 111 113 (face font-lock-string-face))) (header-name . helm-rg--header-name) (keymap keymap (left . helm-rg--file-backward) (right . helm-rg--file-forward) (27 keymap (99 . helm-rg--set-case-sensitivity) (100 . helm-rg--set-dir) (109 . helm-rg--set-extra-args) (103 . helm-rg--set-glob) (98 . helm-rg--bounce)) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." (32 . helm-toggle-visible-mark) (121 keymap ... ... ...) (47 . helm-quit-and-find-file) (71 . helm-end-of-buffer) (107 . helm-previous-line) (106 . helm-next-line) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (103 keymap ... ... ... ...) (93 keymap ...) (91 keymap ...) (tab . helm-select-action) (4 . helm-next-page) (21 . helm-previous-page) (15 . helm-next-source) (14 . helm-next-line) (16 . helm-previous-line) (22 . helm-next-page) (13 . helm-maybe-exit-minibuffer) (2 . helm-previous-page) (6 . helm-next-page) (27 keymap ... ... ... ... ... ...)) (insert-state keymap "Auxiliary keymap for Insert stat..." (15 . helm-next-source) (14 . helm-next-line) (16 . helm-previous-line) (22 . helm-next-page) (13 . helm-maybe-exit-minibuffer) (2 . helm-previous-page) (6 . helm-next-page) (27 keymap ... ... ... ... ... ...)) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil (interactive) (helm-select-nth-action 12)) (f12 lambda nil (interactive) (helm-select-nth-action 11)) (f11 lambda nil (interactive) (helm-select-nth-action 10)) (f10 lambda nil (interactive) (helm-select-nth-action 9)) (f9 lambda nil (interactive) (helm-select-nth-action 8)) (f8 lambda nil (interactive) (helm-select-nth-action 7)) (f7 lambda nil (interactive) (helm-select-nth-action 6)) (f6 lambda nil (interactive) (helm-select-nth-action 5)) (f5 lambda nil (interactive) (helm-select-nth-action 4)) (f4 lambda nil (interactive) (helm-select-nth-action 3)) (f3 lambda nil (interactive) (helm-select-nth-action 2)) (f2 lambda nil (interactive) (helm-select-nth-action 1)) (menu-bar keymap (help-menu keymap ...)) (help keymap (109 . helm-help)) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil (interactive) (helm-select-nth-action 0)) (8 . helm-find-files-up-one-level) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (67108897 . helm-toggle-suspend-update) ...) (action ("Visit" . helm-rg--async-action)) (persistent-action . helm-rg--async-persistent-action) (persistent-help . "Visit result buffer and highligh...") (help-message . "FIXME: useful help message!!!") (filtered-candidate-transformer . helm-grep-fc-transformer) (filter-one-by-one . helm-rg--parse-process-output) (display-to-real . helm-rg--display-to-real) (candidate-number-limit . 99999) (redisplay . identity) (nomark . t) (nohighlight . t) (history . helm-rg--input-history) (header-line . "C-j: Visit result buffer and hig...") (group . helm-rg) (candidates-process . helm-rg--make-process) (pcre . t) (item-count . 179) (incomplete-line . "\33[0m\33[32m36\33[0m") (insertion-marker . #<marker at 115 in *helm-rg*>)) "kgs/nix/mylib.nix\33[0m\n\33[0m\33[32m1...")
	  helm-output-filter(#<process *helm-rg--rg*> "kgs/nix/mylib.nix\33[0m\n\33[0m\33[32m11\33[0m:        lib....")
	  read-from-minibuffer(#("rg pattern: " 0 12 (face helm-minibuffer-prompt)) "" (keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal state" (32 . helm-toggle-visible-mark) (121 keymap (121 . helm-kill-selection-and-quit) (80 . helm-copy-to-buffer) (112 . helm-yank-selection)) (47 . helm-quit-and-find-file) (71 . helm-end-of-buffer) (107 . helm-previous-line) (106 . helm-next-line) (41 . helm-next-visible-mark) (40 . helm-prev-visible-mark) (103 keymap (114 . helm-refresh) (103 . helm-beginning-of-buffer) (106 . helm-next-source) (107 . helm-previous-source)) (93 keymap (93 . helm-next-source)) (91 keymap (91 . helm-previous-source)) (tab . helm-select-action) (4 . helm-next-page) (21 . helm-previous-page) (15 . helm-next-source) (14 . helm-next-line) (16 . helm-previous-line) (22 . helm-next-page) (13 . helm-maybe-exit-minibuffer) (2 . helm-previous-page) (6 . helm-next-page) (27 keymap (118 . helm-previous-page) (107 . helm-previous-line) (106 . helm-next-line) (108 . helm-execute-persistent-action) (93 . helm-next-source) (91 . helm-previous-source))) (insert-state keymap "Auxiliary keymap for Insert state" (15 . helm-next-source) (14 . helm-next-line) (16 . helm-previous-line) (22 . helm-next-page) (13 . helm-maybe-exit-minibuffer) (2 . helm-previous-page) (6 . helm-next-page) (27 keymap (118 . helm-previous-page) (107 . helm-previous-line) (106 . helm-next-line) (108 . helm-execute-persistent-action) (93 . helm-next-source) (91 . helm-previous-source))) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert normal) state") (f13 lambda nil (interactive) (helm-select-nth-action 12)) (f12 lambda nil (interactive) (helm-select-nth-action 11)) (f11 lambda nil (interactive) (helm-select-nth-action 10)) (f10 lambda nil (interactive) (helm-select-nth-action 9)) (f9 lambda nil (interactive) (helm-select-nth-action 8)) (f8 lambda nil (interactive) (helm-select-nth-action 7)) (f7 lambda nil (interactive) (helm-select-nth-action 6)) (f6 lambda nil (interactive) (helm-select-nth-action 5)) (f5 lambda nil (interactive) (helm-select-nth-action 4)) (f4 lambda nil (interactive) (helm-select-nth-action 3)) (f3 lambda nil (interactive) (helm-select-nth-action 2)) (f2 lambda nil (interactive) (helm-select-nth-action 1)) (menu-bar keymap (help-menu keymap (describe keymap (describe-mode . helm-help)))) (help keymap (109 . helm-help)) (23 . #f(compiled-function () (interactive nil) #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil (interactive) (helm-select-nth-action 0)) (8 . helm-find-files-up-one-level) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (67108897 . helm-toggle-suspend-update) (3 keymap (57 . helm-execute-selection-action-at-nth-+9) (56 . helm-execute-selection-action-at-nth-+8) (55 . helm-execute-selection-action-at-nth-+7) (54 . helm-execute-selection-action-at-nth-+6) (53 . helm-execute-selection-action-at-nth-+5) (52 . helm-execute-selection-action-at-nth-+4) (51 . helm-execute-selection-action-at-nth-+3) (50 . helm-execute-selection-action-at-nth-+2) (49 . helm-execute-selection-action-at-nth-+1) (63 . helm-help) (110 . #f(compiled-function () (interactive nil) #<bytecode -0x1d18e98f53ba146d>)) (108 . helm-display-line-numbers-mode) (62 . helm-toggle-truncate-line) (21 . helm-refresh) (6 . helm-follow-mode) (9 . helm-copy-to-buffer) (11 . helm-kill-selection-and-quit) (25 . helm-yank-selection) (37 . helm-exchange-minibuffer-and-header-line) (95 . helm-toggle-full-frame) (45 . helm-swap-windows)) (67108987 . helm-enlarge-window) (67108989 . helm-narrow-window) (19 . undefined) (24 keymap (57 . helm-execute-selection-action-at-nth-+9) (56 . helm-execute-selection-action-at-nth-+8) (55 . helm-execute-selection-action-at-nth-+7) (54 . helm-execute-selection-action-at-nth-+6) (53 . helm-execute-selection-action-at-nth-+5) (52 . helm-execute-selection-action-at-nth-+4) (51 . helm-execute-selection-action-at-nth-+3) (50 . helm-execute-selection-action-at-nth-+2) (49 . helm-execute-selection-action-at-nth-+1) (2 . helm-resume-list-buffers-after-quit) (98 . helm-resume-previous-session-after-quit) (6 . helm-quit-and-find-file)) (11 . helm-delete-minibuffer-contents) (67108896 . helm-toggle-visible-mark-forward) (0 . helm-toggle-visible-mark) (C-M-up . helm-scroll-other-window-down) (C-M-down . helm-scroll-other-window) (M-prior . helm-scroll-other-window-down) (M-next . helm-scroll-other-window) (12 . helm-recenter-top-bottom-other-window) (left . helm-previous-source) (right . helm-next-source) (15 . helm-next-source) (10 . helm-execute-persistent-action) ...) nil nil nil t)
	  helm-read-pattern-maybe("rg pattern: " "" nil nil nil nil nil)
	  helm-internal((helm-rg-process-source) "" "rg pattern: " nil nil "*helm-rg*" nil nil nil)
	  apply(helm-internal ((helm-rg-process-source) "" "rg pattern: " nil nil "*helm-rg*" nil nil nil))
	  helm((helm-rg-process-source) "" "rg pattern: " nil nil "*helm-rg*" nil nil nil)
	  apply(helm ((helm-rg-process-source) "" "rg pattern: " nil nil "*helm-rg*" nil nil nil))
	  helm(:sources (helm-rg-process-source) :buffer "*helm-rg*" :input "" :prompt "rg pattern: ")
	  helm-rg--do-helm-rg("")
	  (unwind-protect (helm-rg--do-helm-rg rg-pattern) (helm-rg--unwind-cleanup))
	  (let* ((helm-rg--current-dir (or helm-rg--current-dir (and pfx default-directory) (helm-rg--interpret-starting-dir helm-rg-default-directory))) (helm-rg--glob-string (or helm-rg--glob-string helm-rg-default-glob-string)) (helm-rg--extra-args (or helm-rg--extra-args helm-rg-default-extra-args)) (helm-rg--paths-to-search (or helm-rg--paths-to-search paths)) (helm-rg--case-sensitivity (or helm-rg--case-sensitivity helm-rg-default-case-sensitivity))) (setq helm-rg--last-dir helm-rg--current-dir) (unwind-protect (helm-rg--do-helm-rg rg-pattern) (helm-rg--unwind-cleanup)))
	  helm-rg("" nil)
	  helm-projectile-rg()
	  funcall-interactively(helm-projectile-rg)
	  call-interactively(helm-projectile-rg record nil)
	  command-execute(helm-projectile-rg record)
	  helm-M-x-execute-command(helm-projectile-rg)
	  helm-execute-selection-action-1()
	  helm-execute-selection-action()
	  helm-internal((((name . "Emacs Commands history") (candidates . #f(compiled-function () #<bytecode 0x18d651da10d3285c>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert stat..." ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keep...") (must-match . t) (group . helm-command) (match-dynamic . t)) ((name . "Emacs Commands") (candidates . #f(compiled-function () #<bytecode -0xdc8c063718a7a86>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert stat..." ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keep...") (must-match . t) (group . helm-command) (match-dynamic . t))) nil "M-x " nil nil "*helm M-x*" nil nil helm-M-x-input-history)
	  apply(helm-internal ((((name . "Emacs Commands history") (candidates . #f(compiled-function () #<bytecode 0x18d651da10d3285c>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal state" ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert state" ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert normal) s...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) (8 . helm-find-files-up-one-level) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (67108897 . helm-toggle-suspend-update) (3 keymap ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (67108987 . helm-enlarge-window) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keeping se...") (must-match . t) (group . helm-command) (match-dynamic . t)) ((name . "Emacs Commands") (candidates . #f(compiled-function () #<bytecode -0xdc8c063718a7a86>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal state" ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert state" ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert normal) s...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) (8 . helm-find-files-up-one-level) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (67108897 . helm-toggle-suspend-update) (3 keymap ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (67108987 . helm-enlarge-window) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keeping se...") (must-match . t) (group . helm-command) (match-dynamic . t))) nil "M-x " nil nil "*helm M-x*" nil nil helm-M-x-input-history))
	  helm((((name . "Emacs Commands history") (candidates . #f(compiled-function () #<bytecode 0x18d651da10d3285c>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert stat..." ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keep...") (must-match . t) (group . helm-command) (match-dynamic . t)) ((name . "Emacs Commands") (candidates . #f(compiled-function () #<bytecode -0xdc8c063718a7a86>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert stat..." ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keep...") (must-match . t) (group . helm-command) (match-dynamic . t))) nil "M-x " nil nil "*helm M-x*" nil nil helm-M-x-input-history)
	  apply(helm ((((name . "Emacs Commands history") (candidates . #f(compiled-function () #<bytecode 0x18d651da10d3285c>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal state" ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert state" ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert normal) s...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) (8 . helm-find-files-up-one-level) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (67108897 . helm-toggle-suspend-update) (3 keymap ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (67108987 . helm-enlarge-window) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keeping se...") (must-match . t) (group . helm-command) (match-dynamic . t)) ((name . "Emacs Commands") (candidates . #f(compiled-function () #<bytecode -0xdc8c063718a7a86>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal state" ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert state" ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert normal) s...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) (8 . helm-find-files-up-one-level) (20 . helm-toggle-resplit-and-swap-windows) (C-tab . undefined) (67108897 . helm-toggle-suspend-update) (3 keymap ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (67108987 . helm-enlarge-window) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keeping se...") (must-match . t) (group . helm-command) (match-dynamic . t))) nil "M-x " nil nil "*helm M-x*" nil nil helm-M-x-input-history))
	  helm(:sources (((name . "Emacs Commands history") (candidates . #f(compiled-function () #<bytecode 0x18d651da10d3285c>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert stat..." ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keep...") (must-match . t) (group . helm-command) (match-dynamic . t)) ((name . "Emacs Commands") (candidates . #f(compiled-function () #<bytecode -0xdc8c063718a7a86>)) (keymap keymap (keymap ...) keymap (21 . helm-M-x-universal-argument) keymap (127 . delete-backward-char) (27 keymap ...) (C-return . helm-cr-empty-string) keymap (26 . helm-select-action) (backtab . helm-find-files-up-one-level) (tab . helm-execute-persistent-action) (normal-state keymap "Auxiliary keymap for Normal stat..." ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...) (insert-state keymap "Auxiliary keymap for Insert stat..." ... ... ... ... ... ... ... ...) (\(insert\ normal\)-state keymap "Auxiliary keymap for (insert nor...") (f13 lambda nil ... ...) (f12 lambda nil ... ...) (f11 lambda nil ... ...) (f10 lambda nil ... ...) (f9 lambda nil ... ...) (f8 lambda nil ... ...) (f7 lambda nil ... ...) (f6 lambda nil ... ...) (f5 lambda nil ... ...) (f4 lambda nil ... ...) (f3 lambda nil ... ...) (f2 lambda nil ... ...) (menu-bar keymap ...) (help keymap ...) (23 . #f(compiled-function () ... #<bytecode -0x1c5fe80e9fba146d>)) (f1 lambda nil ... ...) ...) (action . helm-type-command-actions) (persistent-action . helm-M-x-persistent-action) (persistent-help . "Describe this command") (help-message . helm-M-x-help-message) (requires-pattern . 0) (filtered-candidate-transformer helm-M-x-transformer-no-sort helm-fuzzy-highlight-matches) (volatile . t) (match . identity) (redisplay . identity) (nomark . t) (coerce . helm-symbolify) (header-line . "C-j: Describe this command (keep...") (must-match . t) (group . helm-command) (match-dynamic . t))) :prompt "M-x " :buffer "*helm M-x*" :history helm-M-x-input-history)
	  helm-M-x-read-extended-command([s/\\\(\\w\\\)\ \\\(\\w\\\)/\\1\\n\\2/g connection-failed ansi-color-apply-overlay-face epg-context-signers nix-faces s/7 s/8 eww-handle-link denied custom-face-menu tramp-adb-parse-device-names ediff-restore-protected-variables bbdb-current-record lsp-make-formatting-capabilities vc-git-make-version-backups-p mml-secure-smime-sign-with-sender tramp-gvfs-handle-copy-file woman-last-file-name none-but-delete vc-src-log-switches lsp-ui-flycheck resourceOperations gnus-summary-recenter avl-tree--stack-store--cmacro woman-addition Find\ file\ in\ directory lsp-pyls-plugins-flake8-max-line-length :examined -some\? bibtex-SuppCollection 0 0 :tooltip shr-parse-image-data \" gnus-tree-buffer Edebug\ All\ Defs nnheader-translate-file-chars helm-browse-project-build-buffers-source ediff-windows tramp-rename-files path-dirs s/\\ org-babel-results-keyword request-list dont-create not-at-beginning-of-line gnus-data-mark woman-use-topic-at-point-default doc-view-pdf/ps->png ...])
	  helm-M-x(nil)
	  funcall-interactively(helm-M-x nil)
	  call-interactively(helm-M-x nil nil)
	  command-execute(helm-M-x)
      #+end_example

*** TODO turn off garbage emacs file generation in current directory
*** TODO yasnippet and source code block completion omfg
    
also maybe look at my experiment here again: [[file:~/code/minimal-emacs-literate-workflow/init.el::;; prevent gc during startup][minimal-emacs-literate-workflow config]]

snippets
https://git.sr.ht/~codygman/emacs-config/tree/master/snippets/org-mode
*** TODO use fixed width font for org source buffers
  - otherwise code doesn't align
  - I've done this before elsewhere, maybe see https://git.sr.ht/~codygman/emacs-config/tree/master
  
*** DONE figure out why keybindings aren't taking effect in magit and other buffers
**** in non magit buffer 
SPC SPC runs the command helm-projectile-find-file (found in
evil-normal-state-map), which is an interactive compiled Lisp function
in helm-projectile.el.

It is bound to SPC SPC, SPC p f.

(helm-projectile-find-file &optional ARG)

Use projectile with Helm for finding files in project

With a prefix ARG invalidates the cache first.
**** in magit buffer 
SPC SPC is undefined
**** this was fixed by making sure all states were there and we use override keymap
**** I'm not positive why this worked though
*** DONE helm
**** DONE initial 
**** DONE fix completions not showing up in =SPC f f=
maybe smex or something is doing this?

this never showed up again
*** TODO =SPC *= search word at point through project
*** TODO =SPC s p= search project
*** TODO extended flycheck
**** TODO error navigation using =]e= and =[e=
**** TODO hlint
*** TODO add forge support
*** TODO enable using buttercup tests for everything
**** end result could look like
     #+begin_src emacs-lisp :tangle no
       ;; simple tests that don't require anything extra remain the same
       (it "emacs version should be 28.0.50"
	   (expect emacs-version :to-equal "28.0.50"))

       ;; more complex tests will use the daemon instance of emacs started with invisible frame
       ;; TODO later make a macro to make this even more painless
       (it "emacs version should be 28.0.50"
	   (expect
	    (server-eval-at "foo"
			    (emacs-version :to-equal "28.0.50")))
     #+end_src
     idea from https://github.com/jorgenschaefer/emacs-buttercup/issues/174#issuecomment-625508845
*** TODO make =M-{h,l}= in org insert mode also promote/demote subtree
*** TODO =alt+{l,r}= demote/promote subheading
*** TODO =SPC n l= org store link
*** TODO turn on key statistics thing
*** TODO =SPC w w= maybe to switch buffers more quickly?
*** TODO save file on evil escape
*** TODO eval form at point... current form... or something
C-x C-e is annoying sometimes... I think spacemacs had something for this
*** TODO =RET= should follow org links and not go to next line (evil collection doing this??)
*** TODO switch to help buffer by default after doing =SPC h <somekey>=
   that way I can scroll through it and quit out when I'm done (though maybe I could get used to the "scroll other buffer" workflow that aims to let you keep doing what you were doing
*** TODO maybe make =fj= work as evil escape too since I quickly smash them in the wrong order sometimes
*** TODO hoogle/stackage search in helm
*** TODO github fuzzy search !!! (copy paste code examples from search OoOOOOOO)
*** TODO make helm less obtrusive (helm-swoop in an org src buffer for instance)
    
