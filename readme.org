#+TITLE: codygman's HCI
* Meta 
** What is this?
*** This is my personal human computer interaction interface based on:
**** Emacs
**** [[https://orgmode.org/][Org-mode]] for literate config management, life planning, and so much more
**** Reproducible system level builds with [[https://nixos.org/nix/][Nix]]
**** Reproducible Emacs package builds with [[https://github.com/raxod502/straight.el][straight.el]]
**** [[https://github.com/hlissner/doom-emacs/][doom-emacs]] for modal editing
** Core values:
*** ALWAYS be reproducible
    :PROPERTIES:
    :ID:       2bed02e1-aa52-4332-a4eb-b213ce1b3468
    :END:

    The way you interact with your computer must be rock-solid, have the ability to rollback to any meaningful point in history in case of regressions, and be solid down to the theory behind it.

    Nix provides this guarantee, but sadly the syntax isn't the most pleasing and the documentation can be non-existent.

    If you're willing to "use the source" though, you can attain these guarantees that are necessary in constructing a reliable HCI system that doesn't make you want to pull your hair out.
*** Performance over features
    I've wavered on this one over the years, but hindering the perceptive feeling of something as important as your interface with your computer causes lots of issues and personally led to me not even using it.

    I learned some good lessons about minimalism and the necessity of "just my editor config" that was truly a partial HCI being a full-blown software project with feature-branches, user testing, performance regression testing, etc.
*** Easy to extend
    One thing that makes emacs great is the ability to just change things on the fly.

    This also hurts reproducibility and predictable performance if you aren't careful though.
*** Fuzzy-search and incremental narrowing everywhere
    I'm currently using ivy since doom defaults to it, but in the past I've used and made significant add-ons for helm. I may well start using helm again unless ivy is even easier to customize somehow.

    I would like to make *all* navigation for anything I do on a computer to be done from a common narrowing framework with state of the art fuzzy finding (which I don't recall getting easily with emacs, but see 'flx' for a good start).

**** Navigation for anything I do including but not limited to
***** TODO fuzzy omni-search for everything listed below
      I'd expect this to be slow without lots of work and probably a backing sqlite database, but something similar to [[https://beepb00p.xyz/pkm-search.html][Building personal search infrastructure for your knowledge and code]]. Perhaps that's even exactly what I want. See the [[https://news.ycombinator.com/item?id=22160572][HackerNews discussion]] as well.

      Having things like apple's finder which shows filenames and tons of other stuff would also be nice
***** TODO Github [0/2]
****** TODO general github search/navigation
       =M-x helm-github= would bring up sections

       - notifications
       - repos

       Selecting a notification would open that link in the browser (in the future maybe relevant content and contextual actions via =helm-github-action= or similar. Think things like an action for a PR like =setup branch locally= that opens new perspective, clones the repo, checks out the given branch, open dired, and if supported start up repl that splits below the dired buffer
****** TODO searching github for code snippets
       Frequently I look for examples of how to do things in home-manager in github. One situation is where I don't know how to setup xmonad and configure it with home-manager I can just search github for others configurations like:

       #+begin_example
       filename:home.nix xmonad
       #+end_example

       It's okay to use Github's interface for this, but I'd prefer to stay in emacs and even open the linked results in a temporary buffer. Another nicety would be optional actions to clone the repo somewhere like ~/code or even somewhere contextually relevant like ~/code/nix-configs. All along the way using incremental narrowing.
***** TODO searching email
      I'd like something like =helm-email= which searches all of my emails with fuzzy search. If I transition to something like notmuch again or mu4e then this is a lot more easily possible on my desktop machines, not so sure about mobile however.
***** TODO browsing issue and bug tracking software
****** TODO clubhouse
******* listing "dashboard view" in sections with fuzzy searching
******* contextual opening based on templates
        This one requires much more
****** SOMEDAY (maybe) jira and others
*** Be nice to use
    If it's not subjectively nice for me to use, then I probably won't use it as much as I should.

** TODO Reproducible Quickstart (warning: not idempotent, don't run more than once)
*** Assumes =codygman/hci= repo cloned and setup
**** start emacs in a nix shell
     #+BEGIN_SRC sh
     nix-shell --pure -I nixpkgs=https://github.com/NixOS/nixpkgs-channels/archive/d5291756487d70bc336e33512a9baf9fa1788faf.tar.gz -p emacs git
     #+END_SRC
**** =C-x C-f= your way to ~/hci/readme.org
**** come back to this specific spot from emacs, then tangle or evaluate the source code blocks as appropriate
**** clone =codygman/hci=
     #+begin_src sh :dir ~
     git clone git@github.com:codygman/codygman/hci.git
     #+end_src
**** setup
     :PROPERTIES:
     :ID:       51d79bf3-53bd-4fc4-83d0-8616c0718d65
     :END:
     #+begin_src sh :tangle /tmp/setup.sh
       # mv current emacs somewhere else (or remove if you don't need it)
       mv ~/.emacs.d ~/.bak.emacs.d
       git clone -b develop git://github.com/hlissner/doom-emacs ~/.emacs.d
       ln -rs ~/codygman/hci/doom.d ~/doom.d
       # assuming "personal" env
       cd ~/.emacs.d
       cd MYENV="personal" ./switch.hs
       ~/.emacs.d/bin/doom install
     #+end_src

     #+RESULTS:

**** tangle the above like
***** navigate into the block
***** =SPC u C-c C-v t=
***** =SPC o t= to popup a terminal
***** from within the terminal
      #+BEGIN_SRC sh
        cd /tmp/
        sh setup.sh
      #+END_SRC
**** common issues
***** "'X' and 'Y' have the same priority; use nix-env --set-flag..."
****** python for instance
******* error
        #+begin_example
        error: packages '/nix/store/ghcaj8k1psh6z93pdzajcy9r1337is9j-home-manager-path/lib/python3.7/site-packages/nox/__pycache__/search.cpython-37.pyc' and '/nix/store/7qnzacibiapc2wl49lckh0y7sl6q5hpy-nox-0.0.6/lib/python3.7/site-packages/nox/__pycache__/search.cpython-37.pyc' have the same priority 5; use 'nix-env --set-flag priority NUMBER INSTALLED_PKGNAME' to change the priority of one of the conflicting packages (0 being the highest priority)
        #+end_example
******* =NOTE= the library name immediately after =/store/= is =nox= so it is what is causing the clash
******* resolution
        #+begin_src sh
	  nix-env --uninstall nox
        #+end_src

        #+RESULTS:
****** why does this happen?
******* when you start using [[https://github.com/rycee/home-manager.git][home-manager]] you'll likely already have installed things you want home-manager to install
******* That means since nix at the system level installed them and now home-manager is installing them, they clash because there is no answer to "which is higher priority"
******* the message is technically correct here, but a little misleading for the home-manager centric case where we'd the ideal message would be:
        "Please uninstall the system level version of 'nox' if you want home-manager to manage it, otherwise remove it from your home-manager configuration"
*** TODO make running this a no-op if already installed

** Getting Help
  
   With a many systems on top of systems, complexity abound, and the stakes sometimes high for not being able to figure something out for a given piece of that system seeking out help in the best places and getting it quickly is paramount.

   The following sections are ordered by how often I need to seek out help for that section. This is subject to change, so if doom becomes the thing I seek help out for the least then it will get moved down.

   Within each section, help resources should be ordered mostly according to typical time required to get an answer.

*** Doom
**** [[https://discord.gg/qvGgnVx][doom-emacs Discord]]

     Very active, very helpful. I hear you can use [[https://www.reddit.com/r/emacs/comments/7poez4/emacs_and_discord/dsiyr8n/][Bitlbee, and Bitlbee-Discord to connect with your irc client]]

*** Nix
**** https://discourse.nixos.org/
**** #nix on freenode
***** TODO make this a link to your irc client!
**** [[https://nixos.org/nixpkgs/manual/][Nixpkgs Users and Contributors Guide]]
**** https://nixos.wiki/

*** Emacs
**** [[https://emacs.stackexchange.com/][Emacs stack exchange]]

*** org-mode
**** [[https://www.reddit.com/r/orgmode/][r/orgmode/]]
**** [[https://emacs.stackexchange.com/][Emacs stack exchange]] using the org mode tag
     You should use [[https://github.com/vermiculus/sx.el][stack exchange for emacs]]!

*** straight.el
**** https://github.com/raxod502/straight.el/issues

* Configuration

** Prevent use-package from installing anything

*** Set ensure-function to nil
    #+begin_src emacs-lisp
      (setq use-package-ensure-function 'ignore)
    #+end_src

*** Set package-archives to nil so there's nothing to install from

    Package should already be there, to add a new one add it to home.nix

    #+begin_src emacs-lisp
      (setq package-archives nil)
    #+end_src
** Core Emacs Configuration
*** Keep emacs from littering
#+begin_src emacs-lisp
;; store all backup and autosave files in the tmp dir
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

*** Visuals
**** Org mode
     #+begin_src emacs-lisp
              (setq-default line-spacing 0.1)
              (add-hook 'text-mode-hook
                        (lambda ()
                          (variable-pitch-mode 1)))

              (defun org-mode-visuals ()
                (setq org-indent-mode-turns-off-org-adapt-indentation nil)
                (org-indent-mode 1)
                (olivetti-mode 1)
                (setq org-startup-indented t
                      org-bullets-bullet-list '(" ") ;; no bullets, needs org-bullets package
                      org-ellipsis "  " ;; folding symbol
                      org-pretty-entities t
                      org-hide-emphasis-markers t
                      ;; show actually italicized text instead of /italicized text/
                      org-agenda-block-separator ""
                      org-fontify-whole-heading-line t
                      org-fontify-done-headline t
                      org-fontify-quote-and-verse-blocks t)
                (setq header-line-format " ")
                ;; want to keep ivy fixed width
                ;; https://github.com/abo-abo/swiper/issues/1549
                (setq ivy-switch-buffer-faces-alist '((dired-mode . ivy-subdir)))
                (lambda () (progn
                             (set-face-attribute 'header-line nil  :height 400)
                             (setq left-margin-width 4)
                             (setq right-margin-width 4)
                             (set-window-buffer nil (current-buffer)))) 

                (dolist (face '(org-block-begin-line 
                                org-block-end-line 
                                org-verbatim 
                                org-block 
                                org-code
                                org-link
                                org-block
                                org-table
                                org-property-value
                                org-formula
                                org-tag
                                org-verbatim
                                org-date
                                company-tooltip
                                org-special-keyword
                                org-block-begin-line
                                org-block-end-line
                                org-meta-line
                                org-document-info-keyword
                                ))

                  (set-face-attribute face nil :inherit 'fixed-pitch)

                  ))
                (add-hook 'org-mode-hook 'org-mode-visuals)
     #+end_src
**** Hide annoying things
    #+begin_src emacs-lisp
      (tool-bar-mode -1)
      (toggle-scroll-bar -1)
      (menu-bar-mode -1)
    #+end_src
**** Transparency

#+begin_src emacs-lisp :results silent
 (set-frame-parameter (selected-frame) 'alpha '(95 . 50))
 (add-to-list 'default-frame-alist '(alpha . (95 . 50)))
#+end_src

**** color theme
    #+begin_src emacs-lisp
      ;; TODO figure out why use-package doesn't work here
      (load-theme 'doom-one t)
    #+end_src
*** auth source
#+begin_src emacs-lisp
 (setq auth-sources '("~/.authinfo"))
#+end_src
*** mode line
**** helper functions, set initial state, add hooks
     #+begin_src emacs-lisp
       (require 'ts)

       (defun even-second-p (x)
	 (if x (zerop (mod x 2)) nil))

       (defun most-recent-lorri-event-for-project (&optional skip-debounces)
	 ;; TODO make this return "lorri stopped" if daemon isn't even running
	 ;; orrrr...... highlight lorri text as red  when stopped, green when started
	 ;; if we have more than 3 external async sandbox emacs running, don't start more
	 (let ((emacs-async-running (length (seq-filter (lambda (s) (s-contains? "emacs<" s))
							(mapcar 'process-name (process-list)))))
	       (current-second (ts-second (ts-now))))
	   (when (or skip-debounces (and (even-second-p current-second) (eq emacs-async-running 0)))
	     (async-start
	      (lambda ()
		(require 'projectile)
		(require 'ts)
		(let* ((all-recent-lorri-activity-for-project
			(if (projectile-project-name)
			    (let ((cmd
				   (format "journalctl --user -u lorri --output=short-iso| grep -v identified | grep %s | tail -n1" (projectile-project-name))))
			      ;; (message "all-recent-lorri-activity debug cmd: %s" cmd)
			      (shell-command-to-string cmd))
			  nil))
		       (parsed-lorri-log-line  (progn
						 (string-match
						  "\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9:.]+T.+-[0-9]\\{4\\}\\).+build status, message: BuildEvent(\\([a-z]+\\) {"
						  all-recent-lorri-activity-for-project)

						 (let* ((date (match-string 1 all-recent-lorri-activity-for-project))
							(status (match-string 2 all-recent-lorri-activity-for-project)))
						   ;; TODO if completed, just show minutes ago completed
						   ;; TODO show only largest value completed ago (ex. 5d 5h 55m 3s ago == 5d ago)
						   ;; NOTE preserve the second level granularity of started though!
						   (if (and date status)
						       (format "[lorri (%s)]: %s %s ago" (projectile-project-name) status
							       (replace-regexp-in-string "\\([0-9]+\\) \\([a-z]\\)[a-z]+[, ]?[ ]?" "\\1\\2"  (ts-human-format-duration (ts-difference (ts-now) (ts-parse date)))) )
						     "[lorri]: parse error")))))
		  (if parsed-lorri-log-line
		      parsed-lorri-log-line
		    "[lorri (no project)]")))

	      (lambda (result)
		;; TODO not sure if this is modifying things
		;; (message "result is: %s" result)
		(setq most-recent-lorri-status result)
		(force-mode-line-update t)
		(sit-for 0.1) ;; hopefully this forces a redisplay?
		)))))

       (defun most-recent-lorri-event-for-project-no-debounce ()
	 (most-recent-lorri-event-for-project t))

	 ;; use setq-default to set it for /all/ modes
	 ;; TODO make this use an association list otherwise only the active buffers modeline will be correct 
	 (setq most-recent-lorri-status "[lorri()]: unknown")
	 (add-hook 'post-command-hook 'most-recent-lorri-event-for-project)
	 (advice-add 'most-recent-lorri-event-for-project-no-debounce :after #'direnv-update-directory-environment)
	 ;; (add-hook 'after-save-hook 'most-recent-lorri-event-for-project) ;; TODO do we need this too? Does debounced post-command-hook cover this?
	 ;; (eval-after-load 'magit (add-to-list 'magit-mode-hook 'most-recent-lorri-event-for-project)) ;; TODO we should add this... debounce or no?
	 (add-to-list 'find-file-hook 'most-recent-lorri-event-for-project-no-debounce)
     #+end_src
**** actual mode line format
    #+begin_src emacs-lisp
      (require 'lsp-mode)
      (display-time-mode 1)
      (setq display-time-24hr-format t)

      (setq-default mode-line-format
		    (list
		     mode-line-front-space
		     "%* "
		     '(:eval (propertize "%b " 'face 'font-lock-keyword-face
					 'help-echo (buffer-file-name)))
		     (flycheck-mode flycheck-mode-line)
		     '(:eval (format "%s" most-recent-lorri-status))
		     " "
		     '(:propertize ("" mode-name))
		     " "
		     global-mode-string
		     mode-line-end-spaces
		     ))
    #+end_src
*** Font stuff
    #+begin_src emacs-lisp
      ;; Set default font
      (set-face-attribute 'default nil
			  :family "Source Code Pro"
			  :height 130
			  :weight 'normal
			  :width 'normal)
    #+end_src

    #+RESULTS:
    
*** Set a custom custom-file
    #+begin_src emacs-lisp
      (setq custom-file "~/.emacs-custom.el")
    #+end_src
*** Don't generate annoying backup files in current directory
    #+begin_src emacs-lisp
      (setq backup-directory-alist `(("." . "~/.saves")))
      (setq delete-old-versions t
	    kept-new-versions 6
	    kept-old-versions 2
	    version-control t)
      (setq backup-by-copying-when-linked t)
    #+end_src
*** Make collaboration easier
    #+begin_src emacs-lisp
      (add-hook 'prog-mode-hook 'display-line-numbers-mode)
      (setq-default display-line-numbers-width 4 
		    ;; display-line-numbers-widen t ;; this is kinda vs code like.. I think I don't like it?
		    display-line-numbers-widen nil ;; this is kinda vs code like.. I think I don't like it?
		    )
      (set-face-attribute 'line-number nil
			  ;; :font "Iosevka Term Slab"
			  :background "gray11"
			  :foreground "light slate grey"
			  )
      (set-face-attribute 'line-number-current-line nil
			  ;; :font "Iosevka Term Slab"
			  :background "lightyellow4"
			  :foreground "black"
			  )


    #+end_src

*** Misc
    #+begin_src emacs-lisp
      ;; always follow symlinks and DONT PROMPT ME
      (setq vc-follow-symlinks t)

      (defalias 'yes-or-no-p 'y-or-n-p)

      (setq make-backup-files nil)
      (setq tags-revert-without-query 1)
    #+end_src

** Package configuration
*** use-package
    #+begin_src emacs-lisp
      (require 'use-package)
    #+end_src
*** general
    #+begin_src emacs-lisp
      (use-package general
	:init
	(setq evil-want-keybinding nil
	      evil-want-C-d-scroll t
	      evil-want-C-u-scroll t
	      evil-want-integration t
	      )
	:config
	(general-auto-unbind-keys) ;; NOTE not sure this works?
	(general-evil-setup t)
	(general-imap "j"
	  (general-key-dispatch 'self-insert-command
	    :timeout 0.25
	    ;; TODO make this work so jf writes the file when I enter normal mode
	    ;; "j" '(my-write-then-normal-state)
	    "f" 'evil-normal-state))
	(general-create-definer my-leader-def
	  :prefix "C")
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  "u"   '(universal-argument :which-key "Universal Argument")
	  "tf" '(toggle-frame-fullscreen :which-key "Toggle Fullscreen")
	  "wd" '(delete-window :which-key "Delete Window")
	  "qq" '(save-buffers-kill-terminal :which-key "Quit Emacs")

	  "hf" '(describe-function :which-key "Describe Function")
	  "hk" '(describe-key :which-key "Describe Key")
	  "ha" '(apropos-command :which-key "Apropos Command")

	  ;; window
	  "wm"  '(toggle-maximize-buffer :which-key "maximize buffer")
	  "wh"  '(evil-window-left :which-key "move left")
	  "wj"  '(evil-window-down :which-key "move down a window")
	  "wk"  '(evil-window-up :which-key "move up a window")
	  "wl"  '(evil-window-right :which-key "move right a window")
	  "wv"  '(split-window-right :which-key "split right a window")
	  "ws"  '(split-window-below :which-key "split bottom")
	  )
	)
    #+end_src
*** org
    #+begin_src emacs-lisp
      (use-package org-capture
        :after org
        :init
        ;; TODO remove resources.org

        ;; (let ((filtered-files (-filter (lambda (x) (not (s-contains? "resources.org" x))) (org-agenda-files)))
        ;;      )
        ;; (type-of filtered-files)
        ;; (setq org-refile-targets '((filtered-files :maxlevel . 3))
        ;; 	  )
        ;; )

        ;; works
        ;; (setq org-refile-targets '( ("~/org/inbox.org" :maxlevel . 3) )  )


        ;; doesn't work
        ;; (setq org-refile-targets '( '("~/org/inbox.org")  :maxlevel . 3 )  )


        (setq org-refile-targets '( ("~/org/inbox.org" :maxlevel . 3))  )

        ;; (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))


        (setq org-outline-path-complete-in-steps nil)
        :hook
        (org-capture-mode . evil-insert-state))
      (use-package org
        :init 
        (setq org-log-done 'time)
        (defun my-day-org-agenda ()
          (interactive)
          (let ((org-agenda-span 'day))
            (org-agenda nil "a")
            (progn (switch-to-buffer "*Org Agenda*") (delete-other-windows))
            ))
        :config
        (setq
         org-agenda-files '("~/org/")
         org-directory "~/org"
         org-capture-templates
         '(("t" "Todo" entry (file+headline "~/org/inbox.org" "Inbox")
            "* TODO %?\n  %i\n  %a")
           ("j" "Journal" entry (file+datetree "~/org/journal.org")
            "* %?\nEntered on %U\n  %i\n  %a")
           ("bu" "org reverse datetree test" entry
            (file+function "/tmp/foo.org"
                           org-reverse-datetree-goto-date-in-file)
            "* [[%^{URL}][%^{Description}]] %^g %?")
           ))
        :general
        (my-leader-def
          :states '(normal visual emacs motion)
          :prefix "SPC"
          :keymaps 'override
          :non-normal-prefix "M-SPC"
          :prefix "SPC"
          "oc"  '(counsel-org-capture :which-key "counsel org capture")
          "oa"  '(my-day-org-agenda :which-key "org-agenda")
          "oA"  '(org-agenda :which-key "org-agenda")
          ))

      (use-package company-org-roam
        :config
        (push 'company-org-roam company-backends))

      (use-package org-roam
        :hook
        (after-init . org-roam-mode)
        :custom
        (org-roam-directory "~/org-roam/")
        )

      (use-package evil-org
        :after org
        :config
        (add-hook 'org-mode-hook 'evil-org-mode)
        (add-hook 'evil-org-mode-hook
                  (lambda ()
                    (evil-org-set-key-theme '(textobjects insert navigation additional shift todo heading))))
        (require 'evil-org-agenda)
        (evil-org-agenda-set-keys))
    #+end_src
**** org babel
    #+begin_src emacs-lisp
      (use-package ob
        :after ob-restclient
	:config
	(setq org-confirm-babel-evaluate nil)
	(org-babel-do-load-languages
	 'org-babel-load-languages
	 '((emacs-lisp . t)
	   (shell . t)
	   (restclient . t)
	   (haskell . t)
	   ))

	)
    #+end_src
***** ob-restclient 
    #+begin_src emacs-lisp
      (use-package ob-restclient)
    #+end_src
**** org reverse datetree  for archiving
*****  set archive location and default reverse datetree formats
     #+begin_src emacs-lisp
(setq org-archive-location (concat org-directory "/archived.org::"))
(setq-default org-reverse-datetree-level-formats
              '("%Y"                    ; year
                (lambda (time) (format-time-string "%Y-%m %B" (org-reverse-datetree-monday time))) ; month
                "%Y W%W"                ; week
                "%Y-%m-%d %A"           ; date
                ))
     #+end_src
***** replace default archiving function with our new one
****** give it a better name

       #+begin_src emacs-lisp
             (defun archive-to-reverse-datetree (arg)
               (interactive "P")
               (org-reverse-datetree-refile-to-file
                "~/org/archived.org"
                nil
                :ask-always arg
                :prefer '("CREATED_TIME" "CREATED_AT" "CLOSED")))
       #+end_src

       #+RESULTS:
       : archive-to-reverse-datetree

****** set the default archiving command
       #+begin_src emacs-lisp
       (setq org-archive-default-command 'archive-to-reverse-datetree)

       #+end_src

*** exwm
**** config
    #+begin_src emacs-lisp
      (use-package exwm
	:init
	(setq exwm-input-global-keys
	      `(([?\s-r] . exwm-reset)
		([?\s-i] . exwm-input-release-keyboard)
		;; convenience keybinding, meant to mimic `esc' in Vim bindings
		([?\s-\ ] . helm-run-external-command)
		([?\s-\[] . exwm-reset)))
	(defun exwm-rename-buffer ()
	  (interactive)
	  (exwm-workspace-rename-buffer
	   (concat exwm-class-name ": "
		   (if (<= (length exwm-title) 75) exwm-title
		     (concat (substring exwm-title 0 74) "...")))))

	;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
	(add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
	(add-hook 'exwm-update-title-hook 'exwm-rename-buffer)	:config
	(require 'exwm)
     (require 'exwm-systemtray)
     (exwm-systemtray-enable)
	(exwm-enable)
	;; stop exwm from catching SPC leader key.
	;; the double whitespace is intentional
	;; credit https://github.com/matthuszagh/emacs/blob/5827a8d2ca4e97bf37cfa71dabf9346043573798/layers/exwm-layer.el#L112
	(add-to-list 'exwm-input-prefix-keys ?\  )
	)
    #+end_src
**** notes
***** make sure by default clicking links opens in same tab, or when I use =f= in firefox to highlight/select a link using vimium or saka
#+begin_example 
# default for this was 2 for me, set to 0
browser.link.open_newwindow.restriction

# default was 0 for me, need to set to 1
browser.link.open_newwindow.restriction
#+end_example

****** see 
       #+begin_example 
         Hello iSkyiera

         In the Location bar, type about:config and press Enter. The about:config "This might void your warranty!" warning page may appear.

         Click I'll be careful, I promise!, to continue to the about:config page.

         At the Search area type(or copy/paste the next)
         browser.link.open_newwindow.restriction then, double-click on it
         and change the value to 0 (zero)

         click OK. 

         Do the same with the :
         browser.link.open_newwindow
         and change the value to 1 (one) 
       #+end_example


*** ediff
    #+begin_src emacs-lisp
      (use-package ediff
	:config
	(setq ediff-window-setup-function 'ediff-setup-windows-plain)
	)
    #+end_src

*** which-key
    #+begin_src emacs-lisp
      (use-package which-key
	:init
	(setq which-key-separator " ")
	(setq which-key-prefix-prefix "+")
	:config
	(which-key-mode))
    #+end_src
*** evil and evil collection
    #+begin_src emacs-lisp
      (use-package evil
        :after general
	:config
	(evil-mode 1)
	:general
	;; NOTE For some reason general binding is broken in the evil block
	)

      (use-package evil-collection
	:after evil
	:config
	(evil-collection-init))
    #+end_src
*** evil-magit
    #+begin_src emacs-lisp
      (use-package evil-magit :after evil :config (evil-magit-init))
    #+end_src
*** eshell
    #+begin_src emacs-lisp
      (use-package eshell
	:general
      (my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "ot" 'eshell
	  ))
    #+end_src
*** dired
    #+begin_src emacs-lisp
      (use-package dired
	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "o-" 'dired
	  ))
    #+end_src
*** save-hist-mode           :built-in:
    #+begin_src emacs-lisp
      (use-package savehist
	:init
	(setq savehist-additional-variables
	      '( kill-ring
		 search-ring
		 regexp-search-ring
		 magit-read-rev-history
		 search-ring
		 minibuffer-history
		 read-expression-history
		 helm-history
		 counsel-compile-history
		 ))
	(setq savehist-file "~/.emacs.d/savehist")
	:config
	(savehist-mode 1)
	)

    #+end_src

*** forge
#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src

*** magit
    #+begin_src emacs-lisp
      (use-package magit
	:init
	;; TODO write test for this
	(add-hook 'with-editor-mode-hook 'evil-insert-state)

	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "gg" 'magit-status
	  )
	)
    #+end_src

*** projectile
    #+begin_src emacs-lisp
	    (use-package projectile
	      :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
		"pa" '(projectile-add-known-project :wk "Projectile add known project")
		)
	      :config
	      (projectile-mode +1))
    #+end_src
*** haskell-mode
    #+begin_src emacs-lisp
      (use-package haskell-mode
	:mode ("\\.hs\\'" . haskell-mode)
	:init
	(message "personal haskell-mode loading")
	(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
	(add-hook 'haskell-mode-hook 'haskell-indentation-mode))
    #+end_src
*** flycheck
    #+begin_src emacs-lisp
	    (use-package flycheck
	      :init
	      (setq flycheck-executable-find
		    (lambda (cmd)
		      ;; (message (format "updating default directory with direnv: %s") default-directory)
		      (direnv-update-environment default-directory)
		      ;;(sit-for 1)
		      (executable-find cmd)))
	      ;; (setq-default flycheck-disabled-checkers '(haskell-stack-ghc))
	      (global-flycheck-mode))

      (use-package flycheck-haskell
	:config
	;; :init
	;; (advice-add 'direnv-update-directory-environment :before #'flycheck-haskell-setup)
	:hook (haskell-mode . flycheck-haskell-setup))
    #+end_src
*** direnv mode
    #+begin_src emacs-lisp
    (defun myadvice (&optional directory force-summary)
        ;; (flycheck-haskell-configure)
     )
      (use-package direnv
        :after flycheck-haskell
	:init 
	:config
        
	(direnv-mode))
    #+end_src

*** compilation mode
    #+begin_src emacs-lisp
      (use-package compile
	:init
	(setq compilation-scroll-output t) ;; TODO test

	(require 'ansi-color)
	(defun endless/colorize-compilation ()
	  "Colorize from `compilation-filter-start' to `point'."
	  (let ((inhibit-read-only t))
	    (ansi-color-apply-on-region
	     compilation-filter-start (point))))
	(add-hook 'compilation-filter-hook
		  #'endless/colorize-compilation)

	;; :hook (compilation-filter-hook  endless/colorize-compilation)
	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "cc" '(counsel-compile :which-key "Counsel Compile")
	  "cC" '(recompile :which-key "M-x recompile")
	  )
	)

    #+end_src
*** winner mode
    #+begin_src emacs-lisp
      (use-package winner
	:config
	(winner-mode 1)
	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "wu" '(winner-undo :which-key "Winner Undo")
	  "wr" '(winner-redo :which-key "Winner Redo")
	  )
	)
    #+end_src
*** Helm
#+begin_src emacs-lisp
  (use-package helm-swoop
    :init
    (setq helm-swoop-split-with-multiple-windows t
	  helm-swoop-split-direction 'split-window-vertically
	  helm-swoop-speed-or-color t
	  helm-swoop-split-window-function 'helm-default-display-buffer
	  helm-swoop-pre-input-function (lambda () ""))
    :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	:prefix "SPC"
	"ss" '(helm-swoop :which-key "helm swoop")
	)
    )

    (use-package helm
      :init
      (setq helm-M-x-fuzzy-match t
	    helm-mode-fuzzy-match t
	    helm-buffers-fuzzy-matching t
	    helm-recentf-fuzzy-match t
	    helm-locate-fuzzy-match t
	    helm-semantic-fuzzy-match t
	    helm-imenu-fuzzy-match t
	    helm-completion-in-region-fuzzy-match t
	    helm-candidate-number-list 80
	    ;; helm-split-window-in-side-p t
	    helm-move-to-line-cycle-in-source t
	    helm-echo-input-in-header-line t
	    helm-autoresize-max-height 0
	    helm-autoresize-min-height 20
	    helm-always-two-windows t
	    )
      :general
      ;; TODO change rest of general def's to use this instead of nmap?
      (my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	"ff" 'helm-find-files
	"fr" 'helm-recentf
	":" '(helm-M-x :which-key "M-x")
	"bb" '(switch-to-buffer :which-key "Switch to buffer")
	"bd" '(my/kill-this-buffer :which-key "Kill Buffer")
	"sp" '(helm-projectile-rg :which-key "Search Projectile Project")
	)
      :config
      ;; (use-package helm-flx)
      ;; (use-package helm-fuzzier)
      (use-package helm-rg)
      (helm-mode 1)
      ;; (helm-flx-mode 1)
      ;; (helm-fuzzier-mode 1)
      :bind (:map helm-map
		  ("<tab>" . helm-execute-persistent-action)
		  ("C-h" . helm-find-files-up-one-level)
		  ("<backtab>" . helm-find-files-up-one-level)
		  ("C-z" . helm-select-action)
		  )
      )

    (use-package helm-projectile
      :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	"pp"  '(helm-projectile-switch-project :which-key "switch project")
	"pb"  '(helm-projectile-switch-to-buffer :which-key "switch buffer")
	"pf" 'helm-projectile-find-file
	"SPC" 'helm-projectile-find-file
	)
      )
#+end_src
*** nix-mode
    #+begin_src emacs-lisp
      (use-package nix
        :defer nil
        :mode ("\\.nix\\'" . nix-mode))
    #+end_src
*** lsp
    #+begin_src emacs-lisp
      (use-package lsp-mode
        :hook ((haskell-mode . lsp-deferred)
               (lsp-mode . lsp-enable-which-key-integration))
        :commands (lsp lsp-deferred)
        :config 
        :general
        (my-leader-def
          :states '(normal visual emacs motion)
          :prefix "SPC"
          :keymaps 'haskell-mode-map ;; TODO isn't there an lsp mode map?
          :non-normal-prefix "M-SPC"
          :prefix "SPC"
          "ca" '(lsp-execute-code-action :wk "lsp execute code action")
          )
        )

      (use-package lsp-haskell
        :init
        (setq lsp-haskell-process-path-hie "haskell-language-server")
        (setq lsp-haskell-process-args-hie nil)
        )
      (general-def
        :prefix ", c"
        :states '(normal visual)
        :keymaps 'haskell-mode-map
        "L" 'flycheck-list-errors
        "b" 'flycheck-buffer
        "c" 'flycheck-clear
        "l" 'lsp-ui-flycheck-list
        "n" 'flycheck-next-error
        "p" 'flycheck-previous-error)

      (use-package lsp-ui
        :commands lsp-ui-mode
        :config
        ;; (setq lsp-ui-flycheck-live-reporting nil)
        ;; (setq lsp-ui-sideline-enable nil)
        ;; (setq lsp-ui-doc-enable nil)
        ;; (setq lsp-ui-sideline-show-diagnostics nil)
        )

      (use-package company-lsp
        :config	
        (push 'company-lsp company-backends))

      (use-package company-box
        :hook (company-mode . company-box-mode))

      ;; TODO move company to own block
      (use-package company
        :init
        (add-hook 'haskell-mode-hook 'company-mode)
        :config
        (setq company-minimum-prefix-length 2
              company-idle-delay 0.25)
        (global-company-mode)
        :bind (:map haskell-mode-map
                    ("TAB" . company-indent-or-complete-common)))


    #+end_src
*** yasnippet
    #+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode t)
    (yas-reload-all))
    #+end_src
*** helper functions
**** toggle maximize buffer
     #+begin_src emacs-lisp
       (defun toggle-maximize-buffer () "Maximize buffer"
	      (interactive)
	      (if (= 1 (length (window-list)))
		  (jump-to-register '_)
		(progn
		  (window-configuration-to-register '_)
		  (delete-other-windows))))
     #+end_src
**** kill this buffer
     #+begin_src emacs-lisp
  ;; our own implementation of kill-this-buffer from menu-bar.el
  (defun my/kill-this-buffer (&optional arg)
    "Kill the current buffer.
	    If the universal prefix argument is used then kill also the window."
    (interactive "P")
    (if (window-minibuffer-p)
	(abort-recursive-edit)
      (if (equal '(4) arg)
	  (kill-buffer-and-window)
	(kill-buffer))))
     #+end_src
* NOTE 
  :PROPERTIES:
  :header-args:    :tangle no
  :END:
** This [[https://github.com/codygman/my-emacs-everywhere/blob/4898bc236fcff390d587e69831f3c17019e027f0/emacs-config.org][minimal literate config]] I wrote is probably useful
*** use graphic p stuff 
** Random Things TODO
*** BIG NOTE: crib from [[file:~/code/minimal-emacs-literate-workflow/init.el::;; prevent gc during startup][minimal-emacs-literate-workflow config]]
    also https://git.sr.ht/~codygman/emacs-config/tree/master
*** TODO setup chatting programs with matterbridge
    - irc (just use rcirc, erc, or something)
    
      Then within that same client I should be able to access:

    - Discord 
    - functional programming slack
    - teams

*** TODO try helm again and see if helm-rg is fixed
https://www.reddit.com/r/emacs/comments/htbjeb/helmprojectilerg_is_not_working_as_expected_not/
https://github.com/cosmicexplorer/helm-rg/pull/25 (it's merged into master)

Hm, need to fix =SPC b b= not working because I guess helm isn't loaded yet.. it works after doing any other helm related thing

seems to be working pretty well... what about helm posframe?

https://github.com/tumashu/helm-posframe
*** TODO recency based narrowing suggestions
    whether in helm or ivy... need to take advantage of history

    otherwise the right result is nearly never there...
*** DONE fix company autocomplete jagged rendering
    CLOSED: [2020-08-23 Sun 00:59]
    It seems to come up when I type things like =to=
    
    Or maybe it's based upon length... =up= had 4 or 5 suggestions
    
    When I have 3 it doesn't seem to do quite what I want
    
    =re= seems to have a ton of completions.... so it's a good test
    
    possible solutions that have other niceities:

    company-box
    company-posframe

    unclear if either of these might cause an issue with exwm like opening a new window or soemthing
    
    looks like company-box fixes it up, gives me nice little symbols, and seems faster? wow!
*** TODO investigate aggressive indent mode again for more handsfree whitespace
*** TODO analyze whether org buffers too narrow for literate programming
    I had a few Haskell code blocks I was looking at and a couple were longer
    
    Maybe 100-120 characters wide
    
    They didn't show up nicely at all
    
    I turned off visual line mode and they showed up nicely.. maybe I could do that within org src blocks
*** TODO revisit automagic org source blocks
    
    I have this on github somewhere... the idea is based on yasnippet and executing blocks on yasnippet tab out

    The motivation is to be able to be as close to running commands in a terminal with the benefit of having a log of outputs.
    
    Perhaps add in autonaming of blocks (and easy renaming), then using noweb effortlessly could be very very good

*** TODO toggle for transparency?
*** TODO journalctl mode and binds?
    maybe a hydra for frequent journalctls I look at?
*** TODO =SPC '= search project last thing (or skip this one and use SPC s p all time?)
    huh... =projectile-ripgrep= couldn't find rg? But:
*** TODO look at more extended yasnippet config
    - indent for completion for instance
*** TODO extended flycheck
**** TODO error navigation using =]e= and =[e=
**** TODO hlint
*** TODO checkout potentially alternate helm grep methods
https://www.manueluberti.eu/emacs/2020/02/22/ripgrepping-with-helm/
*** TODO improve dired
    
    - copy file when there are two dired buffers should select the other!
    - dired-plus mode or w/e?
    - maybe all the icons dired? Test if the bug in editable mode is still there
    - incorporate doom things?

*** TODO right align time in modeline
**** resouces
https://emacs.stackexchange.com/questions/5529/how-to-right-align-some-items-in-the-modeline

https://seagle0128.github.io/doom-modeline/
https://github.com/seagle0128/doom-modeline/issues/363#issuecomment-656423259
*** TODO get niv powered emacs package versions working
    should base this off of =hci-core= branch
*** TODO test out hyperbole after seeing that emacs NYC talk and see how it could be useful
I think instant contextually relevant buttons and the like that are super extensible could have a larger affect than I might currently realize
*** TODO enable using buttercup tests for everything
**** end result could look like
     #+begin_src emacs-lisp :tangle no
       ;; simple tests that don't require anything extra remain the same
       (it "emacs version should be 28.0.50"
	   (expect emacs-version :to-equal "28.0.50"))

       ;; more complex tests will use the daemon instance of emacs started with invisible frame
       ;; TODO later make a macro to make this even more painless
       (it "emacs version should be 28.0.50"
	   (expect
	    (server-eval-at "foo"
			    (emacs-version :to-equal "28.0.50")))
     #+end_src
     idea from https://github.com/jorgenschaefer/emacs-buttercup/issues/174#issuecomment-625508845
*** TODO make =M-{h,l}= in org insert mode also promote/demote subtree
*** TODO =alt+{l,r}= demote/promote subheading
*** TODO =SPC n l= org store link
*** TODO turn on key statistics thing
*** TODO =SPC w w= maybe to switch buffers more quickly?
*** TODO save file on evil escape
*** TODO eval form at point... current form... or something
C-x C-e is annoying sometimes... I think spacemacs had something for this
*** TODO =RET= should follow org links and not go to next line (evil collection doing this??)
*** TODO switch to help buffer by default after doing =SPC h <somekey>=
   that way I can scroll through it and quit out when I'm done (though maybe I could get used to the "scroll other buffer" workflow that aims to let you keep doing what you were doing
*** TODO maybe make =fj= work as evil escape too since I quickly smash them in the wrong order sometimes
*** TODO hoogle/stackage search in helm
*** TODO github fuzzy search !!! (copy paste code examples from search OoOOOOOO)
*** TODO make helm less obtrusive (helm-swoop in an org src buffer for instance)
*** TODO hyperbole buttons to clock into org TODOs
    Less for me, more for people who are just using org mode I might suggest it to
*** Finished
**** DONE window management
     SPC j (up) SPC l (left) etc

 I've *really* missed this one.... =C-x o= gets old fast
**** DONE simple flycheck
***** DONE elisp 
***** DONE shellcheck
***** DONE haskell
**** DONE emacs y-or-n-p
**** DONE spc b d kill buffer
**** DONE compilation mode bindings (SPC c c/SPC c C)
**** DONE =SPC w {u,r}= for winner undo/redo
**** DONE add simple lorri modeline for projects
***** TODO add simple output of lorri status
****** We can get lorri's overall status with 
       #+name: lorri-full-output
       #+begin_src emacs-lisp :noweb yes
       (shell-command-to-string "systemctl --user status lorri")
       #+end_src
****** then we can filter that with
       #+name: lorri-filtered-output
       #+begin_src emacs-lisp :noweb yes :var full-output=lorri-full-output
	 (progn () (string-match "Active: \\(.+\\)$" full-output)
	        (match-string 1 full-output))
       #+end_src

       #+RESULTS: lorri-filtered-output
       : inactive (dead)

       #+RESULTS:
****** and finally update the modeline
******* my default modeline is
       #+begin_src emacs-lisp :results raw
       (print mode-line-format)
       #+end_src

       #+RESULTS:
       (%e mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification     mode-line-position evil-mode-line-tag (vc-mode vc-mode)    mode-line-modes mode-line-misc-info mode-line-end-spaces)
******* Now... updating the modeline isn't quite so straight-forward
******** Here's one of the simpler examples I found
	 #+begin_src emacs-lisp
	   ;; use setq-default to set it for /all/ modes
	   (setq mode-line-format
	     (list
	       ;; the buffer name; the file name as a tool tip
	       '(:eval (propertize "%b " 'face 'font-lock-keyword-face
		   'help-echo (buffer-file-name)))

	       ;; line and column
	       "(" ;; '%02' to set to 2 chars at least; prevents flickering
		 (propertize "%02l" 'face 'font-lock-type-face) ","
		 (propertize "%02c" 'face 'font-lock-type-face) 
	       ") "

	       ;; relative position, size of file
	       "["
	       (propertize "%p" 'face 'font-lock-constant-face) ;; % above top
	       "/"
	       (propertize "%I" 'face 'font-lock-constant-face) ;; size
	       "] "

	       ;; the current major mode for the buffer.
	       "["

	       '(:eval (propertize "%m" 'face 'font-lock-string-face
			 'help-echo buffer-file-coding-system))
	       "] "


	       "[" ;; insert vs overwrite mode, input-method in a tooltip
	       '(:eval (propertize (if overwrite-mode "Ovr" "Ins")
			 'face 'font-lock-preprocessor-face
			 'help-echo (concat "Buffer is in "
				      (if overwrite-mode "overwrite" "insert") " mode")))

	       ;; was this buffer modified since the last save?
	       '(:eval (when (buffer-modified-p)
			 (concat ","  (propertize "Mod"
				        'face 'font-lock-warning-face
				        'help-echo "Buffer has been modified"))))

	       ;; is this buffer read-only?
	       '(:eval (when buffer-read-only
			 (concat ","  (propertize "RO"
				        'face 'font-lock-type-face
				        'help-echo "Buffer is read-only"))))  
	       "] "

	       ;; add the time, with the date and the emacs uptime in the tooltip
	       '(:eval (propertize (format-time-string "%H:%M")
			 'help-echo
			 (concat (format-time-string "%c; ")
				 (emacs-uptime "Uptime:%hh"))))
	       " --"
	       ;; i don't want to see minor-modes; but if you want, uncomment this:
	       ;; minor-mode-alist  ;; list of minor modes
	       "%-" ;; fill with '-'
	       ))
	 #+end_src

	 #+RESULTS:
	 | (:eval (propertize %b  'face 'font-lock-keyword-face 'help-echo (buffer-file-name))) | ( | %02l | , | %02c | ) | [ | %p | / | %I | ] | [ | (:eval (propertize %m 'face 'font-lock-string-face 'help-echo buffer-file-coding-system)) | ] | [ | (:eval (propertize (if overwrite-mode Ovr Ins) 'face 'font-lock-preprocessor-face 'help-echo (concat Buffer is in  (if overwrite-mode overwrite insert)  mode))) | (:eval (when (buffer-modified-p) (concat , (propertize Mod 'face 'font-lock-warning-face 'help-echo Buffer has been modified)))) | (:eval (when buffer-read-only (concat , (propertize RO 'face 'font-lock-type-face 'help-echo Buffer is read-only)))) | ] | (:eval (propertize (format-time-string %H:%M) 'help-echo (concat (format-time-string %c; ) (emacs-uptime Uptime:%hh)))) | -- | %- |

******** Now i'll just add my naieve lorri status to the front of that
	 #+begin_src emacs-lisp :tangle no
	   ;; use setq-default to set it for /all/ modes
	   (setq-default mode-line-format
		 (list
		  '(:eval (propertize (progn ()
					     (let ((full-output (shell-command-to-string "systemctl --user status lorri")))
					       (string-match "Active: \\(.+\\)$" full-output)
					       (format "lorri: %s    " (match-string 1 full-output)))
					     )))

		  ;; the buffer name; the file name as a tool tip
		  '(:eval (propertize "%b " 'face 'font-lock-keyword-face
				      'help-echo (buffer-file-name)))

		  ;; line and column
		  "(" ;; '%02' to set to 2 chars at least; prevents flickering
		  (propertize "%02l" 'face 'font-lock-type-face) ","
		  (propertize "%02c" 'face 'font-lock-type-face) 
		  ") "

		  ;; relative position, size of file
		  "["
		  (propertize "%p" 'face 'font-lock-constant-face) ;; % above top
		  "/"
		  (propertize "%I" 'face 'font-lock-constant-face) ;; size
		  "] "

		  ;; the current major mode for the buffer.
		  "["

		  '(:eval (propertize "%m" 'face 'font-lock-string-face
				      'help-echo buffer-file-coding-system))
		  "] "


		  "[" ;; insert vs overwrite mode, input-method in a tooltip
		  '(:eval (propertize (if overwrite-mode "Ovr" "Ins")
				      'face 'font-lock-preprocessor-face
				      'help-echo (concat "Buffer is in "
							 (if overwrite-mode "overwrite" "insert") " mode")))

		  ;; was this buffer modified since the last save?
		  '(:eval (when (buffer-modified-p)
			    (concat ","  (propertize "Mod"
						     'face 'font-lock-warning-face
						     'help-echo "Buffer has been modified"))))

		  ;; is this buffer read-only?
		  '(:eval (when buffer-read-only
			    (concat ","  (propertize "RO"
						     'face 'font-lock-type-face
						     'help-echo "Buffer is read-only"))))  
		  "] "

		  ;; add the time, with the date and the emacs uptime in the tooltip
		  '(:eval (propertize (format-time-string "%H:%M")
				      'help-echo
				      (concat (format-time-string "%c; ")
					      (emacs-uptime "Uptime:%hh"))))
		  " --"
		  ;; i don't want to see minor-modes; but if you want, uncomment this:
		  ;; minor-mode-alist  ;; list of minor modes
		  "%-" ;; fill with '-'
		  ))
	 #+end_src

	 #+RESULTS:
	 | (:eval (propertize (progn nil (let ((full-output (shell-command-to-string systemctl --user status lorri))) (string-match Active: \(.+\)$ full-output) (format lorri: %s     (match-string 1 full-output)))))) | (:eval (propertize %b  'face 'font-lock-keyword-face 'help-echo (buffer-file-name))) | ( | %02l | , | %02c | ) | [ | %p | / | %I | ] | [ | (:eval (propertize %m 'face 'font-lock-string-face 'help-echo buffer-file-coding-system)) | ] | [ | (:eval (propertize (if overwrite-mode Ovr Ins) 'face 'font-lock-preprocessor-face 'help-echo (concat Buffer is in  (if overwrite-mode overwrite insert)  mode))) | (:eval (when (buffer-modified-p) (concat , (propertize Mod 'face 'font-lock-warning-face 'help-echo Buffer has been modified)))) | (:eval (when buffer-read-only (concat , (propertize RO 'face 'font-lock-type-face 'help-echo Buffer is read-only)))) | ] | (:eval (propertize (format-time-string %H:%M) 'help-echo (concat (format-time-string %c; ) (emacs-uptime Uptime:%hh)))) | -- | %- |

******** That's a pretty nice result, but what we really want is to know the last output of the log for that directory
********* all lorri activity for given projectile project
	  #+begin_src emacs-lisp :results raw
	    (defun all-recent-lorri-activity-for-project () 
	    (let ((cmd (format "journalctl --user -u lorri | grep %s | tail -n1" (projectile-project-name))))
	      (message "all-recent-lorri-activity debug cmd: %s" cmd)
	      (shell-command-to-string cmd)))
	   
	  #+end_src

	  #+RESULTS:
	  all-recent-lorri-activity-for-project
********* filter out what we need from that

	  #+begin_src emacs-lisp :results raw
	    (defun most-recent-lorri-event-for-project ()
	      (let ((full-output (all-recent-lorri-activity-for-project))
		    (rgx
		     "]: [a-z]\\{3\\} [0-9]\\{2\\} \\([0-9:.]+\\).+build status, message: BuildEvent(\\([a-z]+\\) {"))
	        (string-match rgx full-output)
	        (format "[lorri] %s: %s"
		        (match-string 1 full-output)
		        (match-string 2 full-output)
		        )) )
	  #+end_src

	  #+RESULTS:
	  most-recent-lorri-event-for-project
	  most-recent-lorri-event-for-project
	  lorri: nil at XXXX   
********* that leaves us in total with
	  #+begin_src emacs-lisp :results raw
	    (defun all-recent-lorri-activity-for-project () 
	      (let ((cmd (format "journalctl --user -u lorri | grep %s | tail -n1" (projectile-project-name))))
	        (message "all-recent-lorri-activity debug cmd: %s" cmd)
	        (shell-command-to-string cmd)))

	    (defun most-recent-lorri-event-for-project ()
	      (let ((full-output (all-recent-lorri-activity-for-project))
		    (rgx
		     "]: [a-z]\\{3\\} [0-9]\\{2\\} \\([0-9:.]+\\).+build status, message: BuildEvent(\\([a-z]+\\) {"))
	        (string-match rgx full-output)
	        (format "[lorri] %s: %s"
		        (match-string 1 full-output)
		        (match-string 2 full-output)
		        )) )

	  #+end_src
********* and our new modeline code as
	  #+begin_src emacs-lisp :results raw 
	  (defun all-recent-lorri-activity-for-project () 
	      (let ((project-name (projectile-project-name)))
	        (if project-name
		    (let ((cmd (format "journalctl --user -u lorri | grep -v identified | grep %s | tail -n1" (projectile-project-name))))
		      ;; (message "all-recent-lorri-activity debug cmd: %s" cmd)
		      (shell-command-to-string cmd))
		  nil
		    )
	      ))

	    (defun parse-lorri-log-line (output)
	      (string-match
	       "]: \\([a-z]\\{3\\} [0-9]\\{2\\} [0-9:.]+\\).+build status, message: BuildEvent(\\([a-z]+\\) {"
	       output)

	      (if (and
		   (match-string 1 output)
		   (match-string 2 output))
		  (format "[lorri] %s: %s"
			  (match-string 1 output)
			  (match-string 2 output))
	        nil)
	      )

	    (defun most-recent-lorri-event-for-project ()
	      (let ((full-output (all-recent-lorri-activity-for-project)))
	        (message "full output: %s" full-output)
	        (let ((result (if full-output
		    (parse-lorri-log-line full-output)	
		  "[lorri (no project)]")))

		  ;; TODO not sure if this is modifying things
		  (setq most-recent-lorri-event-for-project result)
		  (force-mode-line-update)
		  )))

	    ;; use setq-default to set it for /all/ modes
	    ;; TODO make this use an association list otherwise only the active buffers modeline will be correct 
	    (setq most-recent-lorri-status "[lorri]: unknown")
	    (add-hook 'after-save-hook 'most-recent-lorri-event-for-project)
	    (add-to-list 'magit-mode-hook 'most-recent-lorri-event-for-project)
	    (add-to-list 'find-file-hook 'most-recent-lorri-event-for-project)
	    (setq-default mode-line-format
			  (list
			   ;; TODO fix performance issues prob because of tons of errors thrown
			   '(:eval (propertize (format "%s          " 'most-recent-lorri-status)))

			   ;; the buffer name; the file name as a tool tip
			   '(:eval (propertize "%b " 'face 'font-lock-keyword-face
					       'help-echo (buffer-file-name)))

			   ;; line and column
			   "(" ;; '%02' to set to 2 chars at least; prevents flickering
			   (propertize "%02l" 'face 'font-lock-type-face) ","
			   (propertize "%02c" 'face 'font-lock-type-face) 
			   ") "

			   ;; relative position, size of file
			   "["
			   (propertize "%p" 'face 'font-lock-constant-face) ;; % above top
			   "/"
			   (propertize "%I" 'face 'font-lock-constant-face) ;; size
			   "] "

			   ;; the current major mode for the buffer.
			   "["

			   '(:eval (propertize "%m" 'face 'font-lock-string-face
					       'help-echo buffer-file-coding-system))
			   "] "


			   "[" ;; insert vs overwrite mode, input-method in a tooltip
			   '(:eval (propertize (if overwrite-mode "Ovr" "Ins")
					       'face 'font-lock-preprocessor-face
					       'help-echo (concat "Buffer is in "
								  (if overwrite-mode "overwrite" "insert") " mode")))

			   ;; was this buffer modified since the last save?
			   '(:eval (when (buffer-modified-p)
				     (concat ","  (propertize "Mod"
							      'face 'font-lock-warning-face
							      'help-echo "Buffer has been modified"))))

			   ;; is this buffer read-only?
			   '(:eval (when buffer-read-only
				     (concat ","  (propertize "RO"
							      'face 'font-lock-type-face
							      'help-echo "Buffer is read-only"))))  
			   "] "

			   ;; add the time, with the date and the emacs uptime in the tooltip
			   '(:eval (propertize (format-time-string "%H:%M")
					       'help-echo
					       (concat (format-time-string "%c; ")
						       (emacs-uptime "Uptime:%hh"))))
			   " --"
			   ;; i don't want to see minor-modes; but if you want, uncomment this:
			   ;; minor-mode-alist  ;; list of minor modes
			   "%-" ;; fill with '-'
			   ))
	 #+end_src

	 #+RESULTS:
	 ((:eval (propertize (format %s           'most-recent-lorri-status))) (:eval (propertize %b  'face 'font-lock-keyword-face 'help-echo (buffer-file-name))) ( %02l , %02c )  [ %p / %I ]  [ (:eval (propertize %m 'face 'font-lock-string-face 'help-echo buffer-file-coding-system)) ]  [ (:eval (propertize (if overwrite-mode Ovr Ins) 'face 'font-lock-preprocessor-face 'help-echo (concat Buffer is in  (if overwrite-mode overwrite insert)  mode))) (:eval (when (buffer-modified-p) (concat , (propertize Mod 'face 'font-lock-warning-face 'help-echo Buffer has been modified)))) (:eval (when buffer-read-only (concat , (propertize RO 'face 'font-lock-type-face 'help-echo Buffer is read-only)))) ]  (:eval (propertize (format-time-string %H:%M) 'help-echo (concat (format-time-string %c; ) (emacs-uptime Uptime:%hh))))  -- %-)
	 ((:eval (propertize (format %s           'most-recent-lorri-status))) (:eval (propertize %b  'face 'font-lock-keyword-face 'help-echo (buffer-file-name))) ( %02l , %02c )  [ %p / %I ]  [ (:eval (propertize %m 'face 'font-lock-string-face 'help-echo buffer-file-coding-system)) ]  [ (:eval (propertize (if overwrite-mode Ovr Ins) 'face 'font-lock-preprocessor-face 'help-echo (concat Buffer is in  (if overwrite-mode overwrite insert)  mode))) (:eval (when (buffer-modified-p) (concat , (propertize Mod 'face 'font-lock-warning-face 'help-echo Buffer has been modified)))) (:eval (when buffer-read-only (concat , (propertize RO 'face 'font-lock-type-face 'help-echo Buffer is read-only)))) ]  (:eval (propertize (format-time-string %H:%M) 'help-echo (concat (format-time-string %c; ) (emacs-uptime Uptime:%hh))))  -- %-)
	 ((:eval (propertize (format %s           'most-recent-lorri-status))) (:eval (propertize %b  'face 'font-lock-keyword-face 'help-echo (buffer-file-name))) ( %02l , %02c )  [ %p / %I ]  [ (:eval (propertize %m 'face 'font-lock-string-face 'help-echo buffer-file-coding-system)) ]  [ (:eval (propertize (if overwrite-mode Ovr Ins) 'face 'font-lock-preprocessor-face 'help-echo (concat Buffer is in  (if overwrite-mode overwrite insert)  mode))) (:eval (when (buffer-modified-p) (concat , (propertize Mod 'face 'font-lock-warning-face 'help-echo Buffer has been modified)))) (:eval (when buffer-read-only (concat , (propertize RO 'face 'font-lock-type-face 'help-echo Buffer is read-only)))) ]  (:eval (propertize (format-time-string %H:%M) 'help-echo (concat (format-time-string %c; ) (emacs-uptime Uptime:%hh))))  -- %-)
	 ((:eval (propertize (format %s           'most-recent-lorri-status))) (:eval (propertize %b  'face 'font-lock-keyword-face 'help-echo (buffer-file-name))) ( %02l , %02c )  [ %p / %I ]  [ (:eval (propertize %m 'face 'font-lock-string-face 'help-echo buffer-file-coding-system)) ]  [ (:eval (propertize (if overwrite-mode Ovr Ins) 'face 'font-lock-preprocessor-face 'help-echo (concat Buffer is in  (if overwrite-mode overwrite insert)  mode))) (:eval (when (buffer-modified-p) (concat , (propertize Mod 'face 'font-lock-warning-face 'help-echo Buffer has been modified)))) (:eval (when buffer-read-only (concat , (propertize RO 'face 'font-lock-type-face 'help-echo Buffer is read-only)))) ]  (:eval (propertize (format-time-string %H:%M) 'help-echo (concat (format-time-string %c; ) (emacs-uptime Uptime:%hh))))  -- %-)
********* hmm... we need to match both of
********** success
	   #+name: lorri_success_msg
	   #+begin_src example
	   Jul 11 18:52:47 nixos lorri[8799]: Jul 11 18:52:47.266 INFO build status, message: BuildEvent(Completed { nix_file: Shell("/home/cody/code/haskell-nix-stack-workflow/shell.nix"), result: BuildResults { output_paths: OutputPaths { shell_gc_root: RootPath("/home/cody/.cache/lorri/gc_roots/bef519325014d8cb386e7b78179d48ad/gc_root/shell_gc_root") } } })
	   #+end_src
	  
	   #+begin_src emacs-lisp :noweb yes
	   (parse-lorri-log-line "Jul 11 18:52:47 nixos lorri[8799]: Jul 11 18:52:47.266 INFO build status, message: BuildEvent(Completed { nix_file: Shell()")
	   #+end_src

	   #+RESULTS:
	   : [lorri] Jul 11 18:52:47.266: Completed

********** and failure
	   #+name: lorri_failure_msg
	   #+begin_src example
	    Jul 06 20:22:13 nixos lorri[1816]: Jul 06 20:22:13.548 INFO build status, message: BuildEvent(Failure { nix_file: Shell("/home/cody/hci/testdata/haskell-nix-stack-workflow/shell.nix"), failure: Exit { cmd: "\"nix-instantiate\" \"-vv\" \"--add-root\" \"/tmp/.tmp4PJdXs/result\" \"--indirect\" \"--argstr\" \"runtimeClosure\" \"/nix/store/kifdbh1r47rmfi7lndp3vgdh290dy383-runtime-closure.nix\" \"--argstr\" \"shellSrc\" \"/home/cody/hci/testdata/haskell-nix-stack-workflow/shell.nix\" \"--\" \"/home/cody/.cache/lorri/cas/66c4fc8f70f0926419733bdbfd442181\"", status: Some(1), logs: [LogLine("error: getting status of \'/home/cody/hci/testdata/haskell-nix-stack-workflow/shell.nix\': No such file or directory")] } })
	   #+end_src

	   #+begin_src emacs-lisp :noweb yes
	   (parse-lorri-log-line "Jul 06 20:22:13 nixos lorri[1816]: Jul 06 20:22:13.548 INFO build status, message: BuildEvent(Failure { nix_file: Shell(")
	   #+end_src

	   #+RESULTS:
	   : [lorri] Jul 06 20:22:13.548: Failure

********* We'll use rx to do that
********** rx example 
	   #+begin_src emacs-lisp
 (rx bol
   (zero-or-more blank)
   (one-or-more digit)
   ":")
	   #+end_src

	   #+RESULTS:
	   : ^[[:blank:]]*[[:digit:]]+:

********* That modeline still has too much... crap... lets find a more minimal one
********** here one is
	   #+begin_src emacs-lisp
	     (setq-default mode-line-format
			   (list
			    " " mode-line-modified
			    " %[" mode-line-buffer-identification "%] %l %6 "
			    mode-line-misc-info
			    mode-line-end-spaces))
	     ;; (setq global-mode-string '((t jabber-activity-mode-string) "" display-time-string appt-mode-string))
	   #+end_src

	   #+RESULTS:
	   |   | (%1* %1+) | %[ | (%12b) | %] %l %6 | ((which-function-mode (which-func-mode ( which-func-format  ))) (global-mode-string ( global-mode-string  ))) | (:eval (unless (display-graphic-p) -%-)) |
********** then adding my stuff into it

	  #+begin_src emacs-lisp :results raw 
	    (defun all-recent-lorri-activity-for-project () 
	      (let ((project-name (projectile-project-name)))
	        (if project-name
		    (let ((cmd (format "journalctl --user -u lorri | grep -v identified | grep %s | tail -n1" (projectile-project-name))))
		      ;; (message "all-recent-lorri-activity debug cmd: %s" cmd)
		      (shell-command-to-string cmd))
		  nil
		  )
	        ))

	    (defun parse-lorri-log-line (output)
	      (string-match
	       "]: \\([a-z]\\{3\\} [0-9]\\{2\\} [0-9:.]+\\).+build status, message: BuildEvent(\\([a-z]+\\) {"
	       output)

	      (if (and
		   (match-string 1 output)
		   (match-string 2 output))
		  (format "[lorri] %s: %s"
			  (match-string 1 output)
			  (match-string 2 output))
	        nil)
	      )

	    (defun most-recent-lorri-event-for-project ()
	      (let ((full-output (all-recent-lorri-activity-for-project)))
	        (message "full output: %s" full-output)
	        (let ((result (if full-output
				  (parse-lorri-log-line full-output)	
			        "[lorri (no project)]")))

		  ;; TODO not sure if this is modifying things
		  (setq most-recent-lorri-event-for-project result)
		  (force-mode-line-update)
		  )))

	    ;; use setq-default to set it for /all/ modes
	    ;; TODO make this use an association list otherwise only the active buffers modeline will be correct 
	    (setq most-recent-lorri-status "[lorri]: unknown")
	    (add-hook 'after-save-hook 'most-recent-lorri-event-for-project)
	    (add-to-list 'magit-mode-hook 'most-recent-lorri-event-for-project)
	    (add-to-list 'find-file-hook 'most-recent-lorri-event-for-project)
	    (setq-default mode-line-format
			  (list
			   '(:eval (propertize (format "%s          " 'most-recent-lorri-status)))
			   " " mode-line-modified
			   " %[" mode-line-buffer-identification "%] %l %6 "
			   mode-line-misc-info
			   mode-line-end-spaces))
	 #+end_src
******* okay, it's pretty good as of  commit cd25dc00d2327c727bf5b72ed7ba85c465092f5f
**** DONE move back to ivy since helm-rg has bugs in my current emacs system
**** DONE =SPC *= search word at point through project
**** DONE =SPC s p= search project
**** DONE turn off garbage emacs file generation in current directory
**** DONE simple yasnippet and source code block completion omfg
    
 also maybe look at my experiment here again: [[file:~/code/minimal-emacs-literate-workflow/init.el::;; prevent gc during startup][minimal-emacs-literate-workflow config]]

 snippets
 https://git.sr.ht/~codygman/emacs-config/tree/master/snippets/org-mode
**** DONE use fixed width font for org source buffers
   - otherwise code doesn't align
   - I've done this before elsewhere, maybe see https://git.sr.ht/~codygman/emacs-config/tree/master
  
**** DONE figure out why keybindings aren't taking effect in magit and other buffers
***** in non magit buffer 
 SPC SPC runs the command helm-projectile-find-file (found in
 evil-normal-state-map), which is an interactive compiled Lisp function
 in ‘helm-projectile.el’.

 It is bound to SPC SPC, SPC p f.

 (helm-projectile-find-file &optional ARG)

 Use projectile with Helm for finding files in project

 With a prefix ARG invalidates the cache first.
***** in magit buffer 
 SPC SPC is undefined
***** this was fixed by making sure all states were there and we use override keymap
***** I'm not positive why this worked though
**** DONE helm
***** DONE initial 
***** DONE fix completions not showing up in =SPC f f=
 maybe smex or something is doing this?

 this never showed up again
**** DONE add forge support
