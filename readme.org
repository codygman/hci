#+TITLE: codygman's HCI
* What is this?
** This is my personal human computer interaction interface based on:
*** Emacs
*** [[https://orgmode.org/][Org-mode]] for literate config management, life planning, and so much more
*** Reproducible system level builds with [[https://nixos.org/nix/][Nix]]
*** Reproducible Emacs package builds with [[https://github.com/raxod502/straight.el][straight.el]]
*** [[https://github.com/hlissner/doom-emacs/][doom-emacs]] for modal editing
* Core values:
** ALWAYS be reproducible
   :PROPERTIES:
   :ID:       2bed02e1-aa52-4332-a4eb-b213ce1b3468
   :END:

   The way you interact with your computer must be rock-solid, have the ability to rollback to any meaningful point in history in case of regressions, and be solid down to the theory behind it.

   Nix provides this guarantee, but sadly the syntax isn't the most pleasing and the documentation can be non-existent.

   If you're willing to "use the source" though, you can attain these guarantees that are necessary in constructing a reliable HCI system that doesn't make you want to pull your hair out.
** Performance over features
   I've wavered on this one over the years, but hindering the perceptive feeling of something as important as your interface with your computer causes lots of issues and personally led to me not even using it.

   I learned some good lessons about minimalism and the necessity of "just my editor config" that was truly a partial HCI being a full-blown software project with feature-branches, user testing, performance regression testing, etc.
** Easy to extend
   One thing that makes emacs great is the ability to just change things on the fly.

   This also hurts reproducibility and predictable performance if you aren't careful though.
** Fuzzy-search and incremental narrowing everywhere
   I'm currently using ivy since doom defaults to it, but in the past I've used and made significant add-ons for helm. I may well start using helm again unless ivy is even easier to customize somehow.

   I would like to make *all* navigation for anything I do on a computer to be done from a common narrowing framework with state of the art fuzzy finding (which I don't recall getting easily with emacs, but see 'flx' for a good start).

*** Navigation for anything I do including but not limited to
**** TODO fuzzy omni-search for everything listed below
     I'd expect this to be slow without lots of work and probably a backing sqlite database, but something similar to [[https://beepb00p.xyz/pkm-search.html][Building personal search infrastructure for your knowledge and code]]. Perhaps that's even exactly what I want. See the [[https://news.ycombinator.com/item?id=22160572][HackerNews discussion]] as well.

     Having things like apple's finder which shows filenames and tons of other stuff would also be nice
**** TODO Github [0/2]
***** TODO general github search/navigation
      =M-x helm-github= would bring up sections

      - notifications
      - repos

      Selecting a notification would open that link in the browser (in the future maybe relevant content and contextual actions via =helm-github-action= or similar. Think things like an action for a PR like =setup branch locally= that opens new perspective, clones the repo, checks out the given branch, open dired, and if supported start up repl that splits below the dired buffer
***** TODO searching github for code snippets
      Frequently I look for examples of how to do things in home-manager in github. One situation is where I don't know how to setup xmonad and configure it with home-manager I can just search github for others configurations like:

      #+begin_example
      filename:home.nix xmonad
      #+end_example

      It's okay to use Github's interface for this, but I'd prefer to stay in emacs and even open the linked results in a temporary buffer. Another nicety would be optional actions to clone the repo somewhere like ~/code or even somewhere contextually relevant like ~/code/nix-configs. All along the way using incremental narrowing.
**** TODO searching email
     I'd like something like =helm-email= which searches all of my emails with fuzzy search. If I transition to something like notmuch again or mu4e then this is a lot more easily possible on my desktop machines, not so sure about mobile however.
**** TODO browsing issue and bug tracking software
***** TODO clubhouse
****** listing "dashboard view" in sections with fuzzy searching
****** contextual opening based on templates
       This one requires much more
***** SOMEDAY (maybe) jira and others
** Be nice to use
   If it's not subjectively nice for me to use, then I probably won't use it as much as I should.
* TODO Reproducible Quickstart (warning: not idempotent, don't run more than once)
** Assumes =codygman/hci= repo cloned and setup
*** start emacs in a nix shell
    #+BEGIN_SRC sh
    nix-shell --pure -I nixpkgs=https://github.com/NixOS/nixpkgs-channels/archive/d5291756487d70bc336e33512a9baf9fa1788faf.tar.gz -p emacs git
    #+END_SRC
*** =C-x C-f= your way to ~/hci/readme.org
*** come back to this specific spot from emacs, then tangle or evaluate the source code blocks as appropriate
*** clone =codygman/hci=
    #+begin_src sh :dir ~
    git clone git@github.com:codygman/codygman/hci.git
    #+end_src
*** setup
    :PROPERTIES:
    :ID:       51d79bf3-53bd-4fc4-83d0-8616c0718d65
    :END:
    #+begin_src sh :tangle /tmp/setup.sh
      # mv current emacs somewhere else (or remove if you don't need it)
      mv ~/.emacs.d ~/.bak.emacs.d
      git clone -b develop git://github.com/hlissner/doom-emacs ~/.emacs.d
      ln -rs ~/codygman/hci/doom.d ~/doom.d
      # assuming "personal" env
      cd ~/.emacs.d
      cd MYENV="personal" ./switch.hs
      ~/.emacs.d/bin/doom install
    #+end_src

    #+RESULTS:

*** tangle the above like
**** navigate into the block
**** =SPC u C-c C-v t=
**** =SPC o t= to popup a terminal
**** from within the terminal
     #+BEGIN_SRC sh
       cd /tmp/
       sh setup.sh
     #+END_SRC
*** common issues
**** "'X' and 'Y' have the same priority; use nix-env --set-flag..."
***** python for instance
****** error
       #+begin_example
       error: packages '/nix/store/ghcaj8k1psh6z93pdzajcy9r1337is9j-home-manager-path/lib/python3.7/site-packages/nox/__pycache__/search.cpython-37.pyc' and '/nix/store/7qnzacibiapc2wl49lckh0y7sl6q5hpy-nox-0.0.6/lib/python3.7/site-packages/nox/__pycache__/search.cpython-37.pyc' have the same priority 5; use 'nix-env --set-flag priority NUMBER INSTALLED_PKGNAME' to change the priority of one of the conflicting packages (0 being the highest priority)
       #+end_example
****** =NOTE= the library name immediately after =/store/= is =nox= so it is what is causing the clash
****** resolution
       #+begin_src sh
	 nix-env --uninstall nox
       #+end_src

       #+RESULTS:
***** why does this happen?
****** when you start using [[https://github.com/rycee/home-manager.git][home-manager]] you'll likely already have installed things you want home-manager to install
****** That means since nix at the system level installed them and now home-manager is installing them, they clash because there is no answer to "which is higher priority"
****** the message is technically correct here, but a little misleading for the home-manager centric case where we'd the ideal message would be:
       "Please uninstall the system level version of 'nox' if you want home-manager to manage it, otherwise remove it from your home-manager configuration"
** TODO make running this a no-op if already installed
* Getting Help

  With a many systems on top of systems, complexity abound, and the stakes sometimes high for not being able to figure something out for a given piece of that system seeking out help in the best places and getting it quickly is paramount.

  The following sections are ordered by how often I need to seek out help for that section. This is subject to change, so if doom becomes the thing I seek help out for the least then it will get moved down.

  Within each section, help resources should be ordered mostly according to typical time required to get an answer.

** Doom
*** [[https://discord.gg/qvGgnVx][doom-emacs Discord]]

    Very active, very helpful. I hear you can use [[https://www.reddit.com/r/emacs/comments/7poez4/emacs_and_discord/dsiyr8n/][Bitlbee, and Bitlbee-Discord to connect with your irc client]]

** Nix
*** https://discourse.nixos.org/
*** #nix on freenode
**** TODO make this a link to your irc client!
*** [[https://nixos.org/nixpkgs/manual/][Nixpkgs Users and Contributors Guide]]
*** https://nixos.wiki/

** Emacs
*** [[https://emacs.stackexchange.com/][Emacs stack exchange]]

** org-mode
*** [[https://www.reddit.com/r/orgmode/][r/orgmode/]]
*** [[https://emacs.stackexchange.com/][Emacs stack exchange]] using the org mode tag
    You should use [[https://github.com/vermiculus/sx.el][stack exchange for emacs]]!

** straight.el
*** https://github.com/raxod502/straight.el/issues
* Configuration
** Prevent use-package from installing anything
*** Set ensure-function to nil
    #+begin_src emacs-lisp
      (setq use-package-ensure-function 'ignore)
    #+end_src
*** Set package-archives to nil so there's nothing to install from

    Package should already be there, to add a new one add it to home.nix

    #+begin_src emacs-lisp
      (setq package-archives nil)
    #+end_src
** Core Emacs Configuration
*** Font stuff
    #+begin_src emacs-lisp
      ;; Set default font
      (set-face-attribute 'default nil
			  :family "Source Code Pro"
			  :height 120
			  :weight 'normal
			  :width 'normal)
    #+end_src

    #+begin_src emacs-lisp
      (add-hook 'text-mode-hook
		(lambda ()
		  (variable-pitch-mode 1)))
    #+end_src
*** Set a custom custom-file
    #+begin_src emacs-lisp
      (setq custom-file "~/.emacs-custom.el")
    #+end_src
*** Hide annoying things
    #+begin_src emacs-lisp
      (tool-bar-mode -1)
      (toggle-scroll-bar -1)
      (menu-bar-mode -1)
    #+end_src
*** Misc
    #+begin_src emacs-lisp
      ;; always follow symlinks and DONT PROMPT ME
      (setq vc-follow-symlinks t)

      (defalias 'yes-or-no-p 'y-or-n-p)
    #+end_src
** Package configuration
*** use-package
    #+begin_src emacs-lisp
      (require 'use-package)
    #+end_src
*** which-key
    #+begin_src emacs-lisp
      (use-package which-key
	:init
	(setq which-key-separator " ")
	(setq which-key-prefix-prefix "+")
	:config
	(which-key-mode))
    #+end_src
*** general (Best leave this loading near the top)
    #+begin_src emacs-lisp
      (use-package general
	:after which-key
	:init
	(setq evil-want-keybinding nil
	      evil-want-C-d-scroll t
	      evil-want-C-u-scroll t
	      evil-want-integration t
	      )
	:config
	(general-auto-unbind-keys) ;; NOTE not sure this works?
	(general-evil-setup t)
	(general-imap "j"
	  (general-key-dispatch 'self-insert-command
	    :timeout 0.25
	    ;; TODO make this work so jf writes the file when I enter normal mode
	    ;; "j" '(my-write-then-normal-state)
	    "f" 'evil-normal-state))
	(general-create-definer my-leader-def
	  :prefix "C")
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  "u"   '(universal-argument :which-key "Universal Argument")
	  "tf" '(toggle-frame-fullscreen :which-key "Toggle Fullscreen")
	  "wd" '(delete-window :which-key "Delete Window")
	  "qq" '(save-buffers-kill-terminal :which-key "Quit Emacs")

	  "hf" '(describe-function :which-key "Describe Function")
	  "hk" '(describe-key :which-key "Describe Key")
	  "ha" '(apropos-command :which-key "Apropos Command")

	  ;; window
	  "wm"  '(toggle-maximize-buffer :which-key "maximize buffer")
	  "wh"  '(evil-window-left :which-key "move left")
	  "wj"  '(evil-window-down :which-key "move down a window")
	  "wk"  '(evil-window-up :which-key "move up a window")
	  "wl"  '(evil-window-right :which-key "move right a window")
	  "wv"  '(split-window-right :which-key "split right a window")
	  "ws"  '(split-window-below :which-key "split bottom")
	  )
	)
    #+end_src
*** evil and evil collection
    #+begin_src emacs-lisp
      (use-package evil
        :after general
	:config
	(evil-mode 1)
	:general
	;; NOTE For some reason general binding is broken in the evil block
	)

      (use-package evil-collection
	:after evil
	:config
	(evil-collection-init))
    #+end_src
*** evil-magit
    #+begin_src emacs-lisp
      (use-package evil-magit :after evil :config (evil-magit-init))
    #+end_src
*** dired
    #+begin_src emacs-lisp
      (use-package dired
	:general
      (my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "o-" 'dired
	  ))
    #+end_src
*** save-hist-mode           :built-in:
    #+begin_src emacs-lisp
      (use-package savehist
	:init
	(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
	(setq savehist-file "~/.emacs.d/savehist")
	:config
	(savehist-mode 1)
	)

    #+end_src

*** magit
    #+begin_src emacs-lisp
      (use-package magit
	:init
	;; TODO write test for this
	(add-hook 'with-editor-mode-hook 'evil-insert-state)

	:general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	  "gg" 'magit-status
	  )
	)
    #+end_src

*** projectile
    #+begin_src emacs-lisp
	    (use-package projectile
	      :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
		"pa" '(projectile-add-known-project :wk "Projectile add known project")
		)
	      :config
	      (projectile-mode +1))
    #+end_src
*** haskell-mode
    #+begin_src emacs-lisp
      (use-package haskell-mode
	:mode ("\\.hs\\'" . haskell-mode)
	:init
	(message "personal haskell-mode loading")
	(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
	(add-hook 'haskell-mode-hook 'haskell-indentation-mode))
    #+end_src
*** flycheck
    #+begin_src emacs-lisp
      (use-package flycheck
	:ensure t
	:init (global-flycheck-mode))
    #+end_src
*** direnv mode
    #+begin_src emacs-lisp
      (use-package direnv
	:config
	(direnv-mode))
    #+end_src
*** color theme
    #+begin_src emacs-lisp
      ;; TODO figure out why use-package doesn't work here
      (load-theme 'doom-one t)
    #+end_src
*** compilation mode
    #+begin_src emacs-lisp
      (use-package compile
	:init
	(setq compilation-scroll-output t) ;; TODO test

	(require 'ansi-color)
	(defun endless/colorize-compilation ()
	  "Colorize from `compilation-filter-start' to `point'."
	  (let ((inhibit-read-only t))
	    (ansi-color-apply-on-region
	     compilation-filter-start (point))))
	(add-hook 'compilation-filter-hook
		  #'endless/colorize-compilation)

	;; :hook (compilation-filter-hook  endless/colorize-compilation)
	)

    #+end_src
*** winner mode
    #+begin_src emacs-lisp
      (use-package winner
	:config
	(winner-mode 1))
    #+end_src
*** Helm
#+begin_src emacs-lisp
  (use-package helm-swoop
    :init
    (setq helm-swoop-split-with-multiple-windows t
	  helm-swoop-split-direction 'split-window-vertically
	  helm-swoop-speed-or-color t
	  helm-swoop-split-window-function 'helm-default-display-buffer
	  helm-swoop-pre-input-function (lambda () ""))
    :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	:prefix "SPC"
	"ss" '(helm-swoop :which-key "helm swoop")
	)
    )

    (use-package helm
      :init
      (setq helm-M-x-fuzzy-match t
	    helm-mode-fuzzy-match t
	    helm-buffers-fuzzy-matching t
	    helm-recentf-fuzzy-match t
	    helm-locate-fuzzy-match t
	    helm-semantic-fuzzy-match t
	    helm-imenu-fuzzy-match t
	    helm-completion-in-region-fuzzy-match t
	    helm-candidate-number-list 80
	    ;; helm-split-window-in-side-p t
	    helm-move-to-line-cycle-in-source t
	    helm-echo-input-in-header-line t
	    helm-autoresize-max-height 0
	    helm-autoresize-min-height 20
	    helm-always-two-windows t
	    )
      :general
      ;; TODO change rest of general def's to use this instead of nmap?
      (my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	"ff" 'helm-find-files
	":" '(helm-M-x :which-key "M-x")
	"bb" '(switch-to-buffer :which-key "Switch to buffer")
	)
      :config
      ;; (use-package helm-flx)
      ;; (use-package helm-fuzzier)
      (use-package helm-rg)
      (helm-mode 1)
      ;; (helm-flx-mode 1)
      ;; (helm-fuzzier-mode 1)
      :bind (:map helm-map
		  ("<tab>" . helm-execute-persistent-action)
		  ("C-h" . helm-find-files-up-one-level)
		  ("<backtab>" . helm-find-files-up-one-level)
		  ("C-z" . helm-select-action)
		  )
      )

    (use-package helm-projectile
      :general
	(my-leader-def
	  :states '(normal visual emacs motion)
	  :prefix "SPC"
	  :keymaps 'override
	  :non-normal-prefix "M-SPC"
	  :prefix "SPC"
	"pp"  '(helm-projectile-switch-project :which-key "switch project")
	"pb"  '(helm-projectile-switch-to-buffer :which-key "switch buffer")
	"pf" 'helm-projectile-find-file
	"SPC" 'helm-projectile-find-file
	)
      )
#+end_src
*** nix-mode
    #+begin_src emacs-lisp
      (use-package nix
        :defer nil
        :mode ("\\.nix\\'" . nix-mode))
    #+end_src

*** helper functions
**** toggle maximize buffer
     #+begin_src elisp
       (defun toggle-maximize-buffer () "Maximize buffer"
	      (interactive)
	      (if (= 1 (length (window-list)))
		  (jump-to-register '_)
		(progn
		  (window-configuration-to-register '_)
		  (delete-other-windows))))
     #+end_src
* NOTE 
** This [[https://github.com/codygman/my-emacs-everywhere/blob/4898bc236fcff390d587e69831f3c17019e027f0/emacs-config.org][minimal literate config]] I wrote is probably useful
*** use graphic p stuff 
** Random Things TODO
*** BIG NOTE: crib from [[file:~/code/minimal-emacs-literate-workflow/init.el::;; prevent gc during startup][minimal-emacs-literate-workflow config]]
    also https://git.sr.ht/~codygman/emacs-config/tree/master
*** DONE window management
    SPC j (up) SPC l (left) etc

I've *really* missed this one.... =C-x o= gets old fast
*** DONE simple flycheck
**** DONE elisp 
**** DONE shellcheck
**** DONE haskell
*** TODO spc b d kill buffer
*** TODO compilation mode bindings (SPC c c/SPC c C)
*** TODO =SPC w {u,r}= for winner undo/redo
*** TODO turn off garbage emacs file generation in current directory
*** TODO yasnippet and source code block completion omfg
    
also maybe look at my experiment here again: [[file:~/code/minimal-emacs-literate-workflow/init.el::;; prevent gc during startup][minimal-emacs-literate-workflow config]]

snippets
https://git.sr.ht/~codygman/emacs-config/tree/master/snippets/org-mode
*** TODO use fixed width font for org source buffers
  - otherwise code doesn't align
  - I've done this before elsewhere, maybe see https://git.sr.ht/~codygman/emacs-config/tree/master
  
*** DONE figure out why keybindings aren't taking effect in magit and other buffers
**** in non magit buffer 
SPC SPC runs the command helm-projectile-find-file (found in
evil-normal-state-map), which is an interactive compiled Lisp function
in ‘helm-projectile.el’.

It is bound to SPC SPC, SPC p f.

(helm-projectile-find-file &optional ARG)

Use projectile with Helm for finding files in project

With a prefix ARG invalidates the cache first.
**** in magit buffer 
SPC SPC is undefined
**** this was fixed by making sure all states were there and we use override keymap
**** I'm not positive why this worked though
*** DONE helm
**** DONE initial 
**** DONE fix completions not showing up in =SPC f f=
maybe smex or something is doing this?

this never showed up again
*** TODO =SPC *= search word at point through project
*** TODO =SPC s p= search project
*** TODO extended flycheck
**** TODO error navigation using =]e= and =[e=
**** TODO hlint
*** TODO =SPC '= search project (or skip this one and use SPC s p all time?)
    huh... =projectile-ripgrep= couldn't find rg? But:
*** TODO enable using buttercup tests for everything
**** end result could look like
     #+begin_src elisp
       ;; simple tests that don't require anything extra remain the same
       (it "emacs version should be 28.0.50"
	   (expect emacs-version :to-equal "28.0.50"))

       ;; more complex tests will use the daemon instance of emacs started with invisible frame
       ;; TODO later make a macro to make this even more painless
       (it "emacs version should be 28.0.50"
	   (expect
	    (server-eval-at "foo"
			    (emacs-version :to-equal "28.0.50")))
     #+end_src
     idea from https://github.com/jorgenschaefer/emacs-buttercup/issues/174#issuecomment-625508845
*** TODO make =M-{h,l}= in org insert mode also promote/demote subtree
*** TODO =alt+{l,r}= demote/promote subheading
*** TODO =SPC n l= org store link
*** TODO turn on key statistics thing
*** TODO =SPC w w= maybe to switch buffers more quickly?
*** TODO save file on evil escape
*** TODO eval form at point... current form... or something
C-x C-e is annoying sometimes... I think spacemacs had something for this
*** TODO =RET= should follow org links and not go to next line (evil collection doing this??)
*** TODO switch to help buffer by default after doing =SPC h <somekey>=
   that way I can scroll through it and quit out when I'm done (though maybe I could get used to the "scroll other buffer" workflow that aims to let you keep doing what you were doing
*** TODO maybe make =fj= work as evil escape too since I quickly smash them in the wrong order sometimes
*** TODO hoogle/stackage search in helm
*** TODO github fuzzy search !!! (copy paste code examples from search OoOOOOOO)
*** TODO make helm less obtrusive (helm-swoop in an org src buffer for instance)
    
